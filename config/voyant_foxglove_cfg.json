{
  "configById": {
    "3D!3cvisw1": {
      "cameraState": {
        "perspective": true,
        "distance": 4.2927752788580085,
        "phi": 78.97299568694065,
        "thetaOffset": 101.9683624588024,
        "targetOffset": [
          3.5896963284058376,
          0.5681247610452743,
          4.451131822576884e-16
        ],
        "target": [
          0,
          0,
          0
        ],
        "targetOrientation": [
          0,
          0,
          0,
          1
        ],
        "fovy": 45,
        "near": 0.5,
        "far": 5000
      },
      "followMode": "follow-pose",
      "scene": {
        "transforms": {
          "visible": false
        },
        "syncCamera": true
      },
      "transforms": {},
      "topics": {
        "/rng_color_pointcloud": {
          "visible": true,
          "colorField": "z",
          "colorMode": "rgba-fields",
          "colorMap": "turbo"
        }
      },
      "layers": {
        "grid": {
          "visible": false,
          "frameLocked": true,
          "label": "Grid",
          "instanceId": "10139065-341c-4c45-9b7d-b6a8b3fef1c6",
          "layerId": "foxglove.Grid",
          "size": 10,
          "divisions": 10,
          "lineWidth": 1,
          "color": "#248eff",
          "position": [
            0,
            0,
            0
          ],
          "rotation": [
            0,
            0,
            0
          ]
        }
      },
      "publish": {
        "type": "point",
        "poseTopic": "/move_base_simple/goal",
        "pointTopic": "/clicked_point",
        "poseEstimateTopic": "/initialpose",
        "poseEstimateXDeviation": 0.5,
        "poseEstimateYDeviation": 0.5,
        "poseEstimateThetaDeviation": 0.26179939
      },
      "imageMode": {}
    },
    "3D!1pnxa9v": {
      "cameraState": {
        "perspective": true,
        "distance": 4.2927752788580085,
        "phi": 78.97299568694065,
        "thetaOffset": 101.9683624588024,
        "targetOffset": [
          3.5896963284058376,
          0.5681247610452743,
          4.451131822576884e-16
        ],
        "target": [
          0,
          0,
          0
        ],
        "targetOrientation": [
          0,
          0,
          0,
          1
        ],
        "fovy": 45,
        "near": 0.5,
        "far": 5000
      },
      "followMode": "follow-pose",
      "scene": {
        "transforms": {
          "visible": false
        },
        "syncCamera": true
      },
      "transforms": {},
      "topics": {
        "/point_cloud": {
          "visible": false,
          "colorField": "x",
          "colorMode": "flat",
          "colorMap": "rainbow"
        },
        "/dop_color_pointcloud": {
          "visible": true,
          "colorField": "z",
          "colorMode": "rgba-fields",
          "colorMap": "turbo",
          "pointShape": "circle",
          "pointSize": 1.5
        }
      },
      "layers": {
        "grid": {
          "visible": false,
          "frameLocked": true,
          "label": "Grid",
          "instanceId": "8afeb711-8619-4657-815b-25b1b1ea6822",
          "layerId": "foxglove.Grid",
          "size": 10,
          "divisions": 10,
          "lineWidth": 1,
          "color": "#248eff",
          "position": [
            0,
            0,
            0
          ],
          "rotation": [
            0,
            0,
            0
          ]
        }
      },
      "publish": {
        "type": "point",
        "poseTopic": "/move_base_simple/goal",
        "pointTopic": "/clicked_point",
        "poseEstimateTopic": "/initialpose",
        "poseEstimateXDeviation": 0.5,
        "poseEstimateYDeviation": 0.5,
        "poseEstimateThetaDeviation": 0.26179939
      },
      "imageMode": {}
    },
    "3D!16ej2nv": {
      "cameraState": {
        "perspective": true,
        "distance": 4.2927752788580085,
        "phi": 78.97299568694065,
        "thetaOffset": 101.9683624588024,
        "targetOffset": [
          3.5896963284058376,
          0.5681247610452743,
          4.451131822576884e-16
        ],
        "target": [
          0,
          0,
          0
        ],
        "targetOrientation": [
          0,
          0,
          0,
          1
        ],
        "fovy": 45,
        "near": 0.5,
        "far": 5000
      },
      "followMode": "follow-pose",
      "scene": {
        "syncCamera": true,
        "transforms": {
          "visible": false
        }
      },
      "transforms": {},
      "topics": {
        "/ref_color_pointcloud": {
          "visible": true,
          "colorField": "z",
          "colorMode": "rgba-fields",
          "colorMap": "turbo"
        }
      },
      "layers": {
        "grid": {
          "visible": false,
          "drawBehind": false,
          "frameLocked": true,
          "label": "Grid",
          "instanceId": "6d1e413d-67f1-4577-bee1-f6f6233f7b73",
          "layerId": "foxglove.Grid",
          "size": 10,
          "divisions": 10,
          "lineWidth": 1,
          "color": "#248eff",
          "position": [
            0,
            0,
            0
          ],
          "rotation": [
            0,
            0,
            0
          ]
        }
      },
      "publish": {
        "type": "point",
        "poseTopic": "/move_base_simple/goal",
        "pointTopic": "/clicked_point",
        "poseEstimateTopic": "/initialpose",
        "poseEstimateXDeviation": 0.5,
        "poseEstimateYDeviation": 0.5,
        "poseEstimateThetaDeviation": 0.26179939
      },
      "imageMode": {}
    },
    "3D!1sbddfc": {
      "cameraState": {
        "perspective": true,
        "distance": 4.2927752788580085,
        "phi": 78.97299568694065,
        "thetaOffset": 101.9683624588024,
        "targetOffset": [
          3.5896963284058376,
          0.5681247610452743,
          4.451131822576884e-16
        ],
        "target": [
          0,
          0,
          0
        ],
        "targetOrientation": [
          0,
          0,
          0,
          1
        ],
        "fovy": 45,
        "near": 0.5,
        "far": 5000
      },
      "followMode": "follow-pose",
      "scene": {
        "transforms": {
          "visible": false
        },
        "syncCamera": true
      },
      "transforms": {},
      "topics": {
        "/snr_color_pointcloud": {
          "visible": true,
          "colorField": "z",
          "colorMode": "rgba-fields",
          "colorMap": "turbo",
          "pointSize": 1.5
        },
        "/dop_color_pointcloud": {
          "visible": false,
          "colorField": "z",
          "colorMode": "rgba-fields",
          "colorMap": "turbo"
        },
        "/point_cloud": {
          "visible": false
        }
      },
      "layers": {
        "grid": {
          "visible": false,
          "frameLocked": true,
          "label": "Grid",
          "instanceId": "8afeb711-8619-4657-815b-25b1b1ea6822",
          "layerId": "foxglove.Grid",
          "size": 10,
          "divisions": 10,
          "lineWidth": 1,
          "color": "#248eff",
          "position": [
            0,
            0,
            0
          ],
          "rotation": [
            0,
            0,
            0
          ]
        }
      },
      "publish": {
        "type": "point",
        "poseTopic": "/move_base_simple/goal",
        "pointTopic": "/clicked_point",
        "poseEstimateTopic": "/initialpose",
        "poseEstimateXDeviation": 0.5,
        "poseEstimateYDeviation": 0.5,
        "poseEstimateThetaDeviation": 0.26179939
      },
      "imageMode": {}
    },
    "GlobalVariableSliderPanel!3q2vfoj": {
      "sliderProps": {
        "min": 5,
        "max": 200,
        "step": 0.5
      },
      "globalVariableName": "range_band",
      "foxglovePanelTitle": "Range Band (m)"
    },
    "GlobalVariableSliderPanel!2gxsope": {
      "sliderProps": {
        "min": 0,
        "max": 3,
        "step": 0.1
      },
      "globalVariableName": "min_dop_bound",
      "foxglovePanelTitle": "Doppler Min bound -ve(m/s)"
    },
    "GlobalVariableSliderPanel!5wqrfj": {
      "sliderProps": {
        "min": 0,
        "max": 3,
        "step": 0.1
      },
      "globalVariableName": "max_dop_bound",
      "foxglovePanelTitle": "Doppler Max bound (m/s)"
    },
    "GlobalVariableSliderPanel!6ref01": {
      "sliderProps": {
        "min": 0,
        "max": 125,
        "step": 0.1
      },
      "globalVariableName": "min_ref_bound",
      "foxglovePanelTitle": "Reflectance Min Bound (dB)"
    },
    "GlobalVariableSliderPanel!6ref02": {
      "sliderProps": {
        "min": 0,
        "max": 125,
        "step": 0.1
      },
      "globalVariableName": "max_ref_bound",
      "foxglovePanelTitle": "Reflectance Max Bound (dB)"
    },
    "GlobalVariableSliderPanel!3qbvnjm": {
      "sliderProps": {
        "min": 0,
        "max": 100,
        "step": 0.1
      },
      "globalVariableName": "min_snr_bound",
      "foxglovePanelTitle": "SNR Min Bound (dB)"
    },
    "GlobalVariableSliderPanel!2e7ijri": {
      "sliderProps": {
        "min": 0,
        "max": 100,
        "step": 0.1
      },
      "globalVariableName": "max_snr_bound",
      "foxglovePanelTitle": "SNR Max Bound (dB)"
    }
  },
  "globalVariables": {
    "globalVariable": 2,
    "min_snr_bound": 0,
    "max_snr_bound": 100,
    "min_dop_bound": 0.3,
    "max_dop_bound": 0.3,
    "range_band": 5,
    "min_ref_bound": 45,
    "max_ref_bound": 100
  },
  "userNodes": {
    "869d30d4-e1a0-4e9f-aea6-f6dc80f4858a": {
      "sourceCode":
          "// Copyright (c) 2024-2025 Voyant Photonics, Inc.\n//\n// This example code is licensed under the MIT License.\n// See the LICENSE file in the repository root for full license text.\n\nimport { Input } from \"./types\";\nimport { PointCloud, PackedElementField } from \"@foxglove/schemas\";\n\n// The input and output topics for your script\nexport const inputs = [\"/point_cloud\"];\nexport const output = \"/snr_color_pointcloud\";\n\ntype GlobalVariables = {\n    min_snr_bound: number;\n    max_snr_bound: number;\n};\n\n// SNR color configuration\nconst SNR_COLORS: [number, number, number][] = [\n    [7, 107, 236], // Low SNR (blue)\n    [255, 0, 127], // Mid SNR (magenta)\n    [255, 204, 0], // High SNR (yellow)\n];\n\n// Pre-compute the color map\nconst colorMap = createLinearColorMap(SNR_COLORS);\n\n// Output point cloud field structure with XYZRGBA\nconst XYZRGBA_FIELDS: PackedElementField[] = [\n    { name: \"x\", offset: 0, type: 7 }, // FLOAT32\n    { name: \"y\", offset: 4, type: 7 }, // FLOAT32\n    { name: \"z\", offset: 8, type: 7 }, // FLOAT32\n    { name: \"red\", offset: 12, type: 1 }, // UINT8\n    { name: \"green\", offset: 13, type: 1 }, // UINT8\n    { name: \"blue\", offset: 14, type: 1 }, // UINT8\n    { name: \"alpha\", offset: 15, type: 1 }, // UINT8\n];\n\nconst XYZRGBA_STRIDE = 16;\n\n/**\n * Creates a linear color mapping between three colors\n * @param colors Array of three [r,g,b] colors representing low, mid, and high values\n * @returns A 256-entry color map with interpolated values\n */\nfunction createLinearColorMap(colors: [number, number, number][]): number[][] {\n    if (colors.length !== 3) {\n        throw new Error(\"Color map requires exactly 3 colors (low, mid, high)\");\n    }\n\n    const [colorLow, colorMid, colorHigh] = colors;\n    const colorMap: number[][] = [];\n\n    // Create 256 interpolated colors\n    for (let i = 0; i < 256; i++) {\n        const normVal = i / 255;\n        let r, g, b;\n\n        if (normVal < 0.5) {\n            // Interpolate between low and mid colors\n            const factor = normVal * 2;\n            r = colorLow[0] + factor * (colorMid[0] - colorLow[0]);\n            g = colorLow[1] + factor * (colorMid[1] - colorLow[1]);\n            b = colorLow[2] + factor * (colorMid[2] - colorLow[2]);\n        } else {\n            // Interpolate between mid and high colors\n            const factor = (normVal - 0.5) * 2;\n            r = colorMid[0] + factor * (colorHigh[0] - colorMid[0]);\n            g = colorMid[1] + factor * (colorHigh[1] - colorMid[1]);\n            b = colorMid[2] + factor * (colorHigh[2] - colorMid[2]);\n        }\n\n        colorMap.push([Math.round(r), Math.round(g), Math.round(b)]);\n    }\n\n    return colorMap;\n}\n\n/**\n * Converts SNR values to RGB colors using the provided color map\n * @param colorMap The color map to use for conversion\n * @param snrValues Array of SNR values (in dB)\n * @param minSnr Minimum SNR value for normalization (0 = auto)\n * @param maxSnr Maximum SNR value for normalization (0 = auto)\n * @returns Array of RGB values corresponding to the input SNR values\n */\nfunction mapSnrToRgb(\n    colorMap: number[][],\n    snrValues: number[],\n    minSnr: number,\n    maxSnr: number,\n): number[][] {\n    // Auto-range if both bounds are set to 0\n    if (minSnr == 0.0 && maxSnr == 0.0) {\n        minSnr = Math.min(...snrValues);\n        maxSnr = Math.max(...snrValues);\n    }\n\n    // Find actual min/max within bounds\n    const validMin = Math.max(minSnr, Math.min(...snrValues));\n    const validMax = Math.min(maxSnr, Math.max(...snrValues));\n    const range = validMax - validMin;\n\n    return snrValues.map((value) => {\n        // Clip to min/max bounds\n        const clippedValue = Math.min(Math.max(value, validMin), validMax);\n\n        // Normalize to 0-255 range\n        const normalizedValue =\n            range === 0\n                ? 128 // Default to middle value if range is zero\n                : ((clippedValue - validMin) / range) * 255;\n\n        // Get color map index (ensuring it's within bounds)\n        const index = Math.min(Math.max(Math.round(normalizedValue), 0), 255);\n\n        return colorMap[index];\n    });\n}\n\n/**\n * Converts a 4-byte Uint8Array to a Float32 value\n * @param bytes 4-byte Uint8Array\n * @returns Float32 value\n */\nfunction bytesToFloat32(bytes: Uint8Array): number {\n    const dataView = new DataView(bytes.buffer, bytes.byteOffset, 4);\n    return dataView.getFloat32(0, true); // true for little-endian\n}\n\n/**\n * Safely converts a linear value to dB scale\n * @param val Linear value\n * @returns dB value, or -100 for zero/negative values\n */\nfunction safeLog10dB(val: number): number {\n    if (val > 0) {\n        return 10 * Math.log10(val);\n    }\n    return -100;\n}\n\n/**\n * Main script function to process point cloud data and color it based on SNR values\n * @param event Input event containing LiDAR point cloud data\n * @param globalVars Global variables for SNR bounds\n * @returns Modified point cloud with added color information\n */\nexport default function script(\n    event: Input<\"/point_cloud\">,\n    globalVars: GlobalVariables,\n): PointCloud {\n    // Define interfaces that match the message structure\n    interface ROS2PointCloudMessage {\n        row_step: number;\n        point_step: number;\n        data: Uint8Array;\n        header: {\n            stamp: {\n                sec: number;\n                nsec: number;\n            };\n            frame_id: string;\n        };\n    }\n\n    interface APIPointCloudMessage {\n        point_stride: number;\n        data: Uint8Array;\n        timestamp: {\n            sec: number;\n            nsec: number;\n        };\n        frame_id: string;\n        fields: any[];\n    }\n\n    // Type guard functions\n    // This is used because TypeScript can't infer the type of the message during compilation, but we can check it at runtime\n    // Ref: https://www.typescriptlang.org/docs/handbook/advanced-types.html#using-the-in-operator\n    function isROS2PointCloud(message: any): message is ROS2PointCloudMessage {\n        return \"row_step\" in message && \"point_step\" in message;\n    }\n\n    function isAPIPointCloud(message: any): message is APIPointCloudMessage {\n        return \"point_stride\" in message;\n    }\n\n    if (isROS2PointCloud(event.message)) {\n        // Process ROS2 point cloud message\n        const {\n            data,\n            point_step: originalStride,\n            header: ros_header,\n        } = event.message;\n\n        return processROS2PointCloud(\n            data,\n            originalStride,\n            ros_header,\n            globalVars,\n        );\n    } else if (isAPIPointCloud(event.message)) {\n        // Process API point cloud message\n        return processAPIPointCloud(event.message, globalVars);\n    } else {\n        throw new Error(\"Unknown point cloud message format\");\n    }\n}\n\n/**\n * Extracts XYZ and SNR values from point cloud data\n * @param data Raw point cloud data\n * @param stride Point stride in bytes\n * @param numPoints Number of points in the cloud\n * @param XYZ_OFFSET Offset of the XYZ fields in bytes\n * @param SNR_OFFSET Offset of the SNR field in bytes\n * @returns Object containing xyz positions and SNR values\n */\nfunction extractXYZAndSNR(\n    data: Uint8Array,\n    stride: number,\n    numPoints: number,\n    XYZ_OFFSET: number,\n    SNR_OFFSET: number,\n): { xyz: Float32Array; snrValues: number[] } {\n    const xyz = new Float32Array(numPoints * 3);\n    const snrValues: number[] = [];\n\n    for (let i = 0; i < numPoints; i++) {\n        const pointOffset = i * stride;\n\n        // Extract XYZ (12 bytes starting at XYZ_OFFSET)\n        const xyzView = new DataView(\n            data.buffer,\n            data.byteOffset + pointOffset,\n            stride,\n        );\n        xyz[i * 3] = xyzView.getFloat32(XYZ_OFFSET, true); // x\n        xyz[i * 3 + 1] = xyzView.getFloat32(XYZ_OFFSET + 4, true); // y\n        xyz[i * 3 + 2] = xyzView.getFloat32(XYZ_OFFSET + 8, true); // z\n\n        // Extract SNR and convert to dB\n        const snrBytes = data.slice(\n            pointOffset + SNR_OFFSET,\n            pointOffset + SNR_OFFSET + 4,\n        );\n        const snrValue = bytesToFloat32(snrBytes);\n        // Safely convert to dB scale\n        const snrDb = safeLog10dB(snrValue);\n        snrValues.push(snrDb);\n    }\n\n    return { xyz, snrValues };\n}\n\n/**\n * Creates XYZRGBA point cloud from positions and colors\n * @param xyz Float32Array of XYZ positions (length = numPoints * 3)\n * @param colors RGB color values for each point\n * @param numPoints Number of points in the cloud\n * @returns New Uint8Array with XYZRGBA data\n */\nfunction createXYZRGBAPointCloud(\n    xyz: Float32Array,\n    colors: number[][],\n    numPoints: number,\n): Uint8Array {\n    const newSize = numPoints * XYZRGBA_STRIDE;\n    const newData = new Uint8Array(newSize);\n\n    for (let i = 0; i < numPoints; i++) {\n        const offset = i * XYZRGBA_STRIDE;\n\n        // Write XYZ (12 bytes)\n        const xyzView = new DataView(newData.buffer, offset, 12);\n        xyzView.setFloat32(0, xyz[i * 3], true); // x\n        xyzView.setFloat32(4, xyz[i * 3 + 1], true); // y\n        xyzView.setFloat32(8, xyz[i * 3 + 2], true); // z\n\n        // Write RGBA (4 bytes)\n        if (i < colors.length && colors[i]) {\n            const [r, g, b] = colors[i].map((v) =>\n                Math.round(Math.max(0, Math.min(255, v))),\n            );\n            newData[offset + 12] = r;\n            newData[offset + 13] = g;\n            newData[offset + 14] = b;\n            newData[offset + 15] = 255; // alpha\n        } else {\n            // Fallback color if data is missing\n            // TODO: Make sure this never get executed\n            newData[offset + 12] = 128; // r\n            newData[offset + 13] = 128; // g\n            newData[offset + 14] = 128; // b\n            newData[offset + 15] = 255; // alpha\n        }\n    }\n\n    return newData;\n}\n\n/**\n * Processes a ROS2 PointCloud2 message and adds color information based on SNR values\n * @param data Point cloud data as Uint8Array\n * @param originalStride Original point stride in bytes\n * @param ros_header ROS2 message header\n * @param globalVars Global variables for SNR bounds\n * @returns Modified PointCloud message with color information\n */\nfunction processROS2PointCloud(\n    data: Uint8Array,\n    originalStride: number,\n    ros_header: {\n        stamp: {\n            sec: number;\n            nsec: number;\n        };\n        frame_id: string;\n    },\n    globalVars: GlobalVariables,\n) {\n    const XYZ_OFFSET = 0;\n    const SNR_OFFSET = 20;\n    const numPoints = data.length / originalStride;\n\n    // Extract XYZ and SNR values\n    const { xyz, snrValues } = extractXYZAndSNR(\n        data,\n        originalStride,\n        numPoints,\n        XYZ_OFFSET,\n        SNR_OFFSET,\n    );\n\n    // Convert SNR values to RGB colors\n    const rgbColors = mapSnrToRgb(\n        colorMap,\n        snrValues,\n        globalVars.min_snr_bound,\n        globalVars.max_snr_bound,\n    );\n\n    // Create the new point cloud data with added color information\n    const coloredPointCloud = createXYZRGBAPointCloud(\n        xyz,\n        rgbColors,\n        numPoints,\n    );\n\n    // Return the modified point cloud message\n    return {\n        timestamp: {\n            sec: ros_header.stamp.sec,\n            nsec: ros_header.stamp.nsec,\n        },\n        frame_id: ros_header.frame_id,\n        pose: {\n            position: { x: 0, y: 0, z: 0 },\n            orientation: { x: 0, y: 0, z: 0, w: 1 },\n        },\n        point_stride: XYZRGBA_STRIDE,\n        fields: XYZRGBA_FIELDS,\n        data: coloredPointCloud,\n    };\n}\n\n/**\n * Processes an API PointCloud message and adds color information based on SNR values\n * @param api_message API PointCloud message\n * @param globalVars Global variables for SNR bounds\n * @returns Modified PointCloud message with color information\n */\nfunction processAPIPointCloud(\n    api_message: {\n        data: Uint8Array;\n        point_stride: number;\n        timestamp: {\n            sec: number;\n            nsec: number;\n        };\n        frame_id: string;\n        fields: any[];\n    },\n    globalVars: GlobalVariables,\n) {\n    const XYZ_OFFSET = 8;\n    const SNR_OFFSET = 24;\n\n    // Get the original point cloud data as a Uint8Array\n    const {\n        data,\n        point_stride: old_strid,\n        timestamp: ts,\n        frame_id: fid,\n    } = api_message;\n\n    const numPoints = Math.floor(data.length / old_strid);\n\n    // Extract XYZ and SNR values\n    const { xyz, snrValues } = extractXYZAndSNR(\n        data,\n        old_strid,\n        numPoints,\n        XYZ_OFFSET,\n        SNR_OFFSET,\n    );\n\n    // Convert SNR values to RGB colors\n    const rgbColors = mapSnrToRgb(\n        colorMap,\n        snrValues,\n        globalVars.min_snr_bound,\n        globalVars.max_snr_bound,\n    );\n\n    // Create the new point cloud data with added color information\n    const coloredPointCloud = createXYZRGBAPointCloud(\n        xyz,\n        rgbColors,\n        numPoints,\n    );\n\n    // Return the modified point cloud message\n    return {\n        timestamp: {\n            sec: ts.sec,\n            nsec: ts.nsec,\n        },\n        frame_id: fid,\n        pose: {\n            position: { x: 0, y: 0, z: 0 },\n            orientation: { x: 0, y: 0, z: 0, w: 1 },\n        },\n        point_stride: XYZRGBA_STRIDE,\n        fields: XYZRGBA_FIELDS,\n        data: coloredPointCloud,\n    };\n}\n",
      "name": "snr_color_add_fields.ts"
    },
    "87132b73-8226-4e15-9e26-b4dd44475001": {
      "sourceCode":
          "// Copyright (c) 2024-2025 Voyant Photonics, Inc.\n//\n// This example code is licensed under the MIT License.\n// See the LICENSE file in the repository root for full license text.\n\nimport { Input } from \"./types\";\nimport { PointCloud, PackedElementField } from \"@foxglove/schemas\";\n\n// The input and output topics for your script\nexport const inputs = [\"/point_cloud\"];\nexport const output = \"/dop_color_pointcloud\";\n\n// Type definitions\ntype GlobalVariables = {\n    min_dop_bound: number;\n    max_dop_bound: number;\n};\ntype RGBColor = [number, number, number];\n\n// Color constants\nconst DOPPLER_COLORS: RGBColor[] = [\n    [0.0, 100.0, 255.0], // Blue for negative doppler (moving towards)\n    [49.0, 49.0, 49.0], // Gray for zero doppler\n    [255.0, 0.0, 0.0], // Red for positive doppler (moving away)\n];\n\n// Pre-compute the color map\nconst dopColorMap = createLinearColorMap(DOPPLER_COLORS);\n\n// Output point cloud field structure with XYZRGBA\nconst XYZRGBA_FIELDS: PackedElementField[] = [\n    { name: \"x\", offset: 0, type: 7 }, // FLOAT32\n    { name: \"y\", offset: 4, type: 7 }, // FLOAT32\n    { name: \"z\", offset: 8, type: 7 }, // FLOAT32\n    { name: \"red\", offset: 12, type: 1 }, // UINT8\n    { name: \"green\", offset: 13, type: 1 }, // UINT8\n    { name: \"blue\", offset: 14, type: 1 }, // UINT8\n    { name: \"alpha\", offset: 15, type: 1 }, // UINT8\n];\n\nconst XYZRGBA_STRIDE = 16;\n\n/**\n * Creates a linear color gradient map between given color points\n * @param colors Array of RGB triplets defining the gradient points\n * @returns 2D array with 256 RGB color values\n */\nfunction createLinearColorMap(colors: RGBColor[]): number[][] {\n    // Extract colors from the input array\n    const [colorLow, colorMid, colorHigh] = colors;\n    const colorMap: number[][] = [];\n\n    // Create 256 interpolated colors\n    for (let i = 0; i < 256; i++) {\n        const normVal = i / 255.0;\n        let r, g, b;\n\n        if (normVal < 0.5) {\n            // Interpolate between low and mid\n            const factor = normVal * 2.0;\n            r = interpolate(colorLow[0], colorMid[0], factor);\n            g = interpolate(colorLow[1], colorMid[1], factor);\n            b = interpolate(colorLow[2], colorMid[2], factor);\n        } else {\n            // Interpolate between mid and high\n            const factor = (normVal - 0.5) * 2.0;\n            r = interpolate(colorMid[0], colorHigh[0], factor);\n            g = interpolate(colorMid[1], colorHigh[1], factor);\n            b = interpolate(colorMid[2], colorHigh[2], factor);\n        }\n\n        colorMap.push([r, g, b]);\n    }\n\n    return colorMap;\n}\n\n/**\n * Linear interpolation between two values\n * @param a Starting value\n * @param b Ending value\n * @param t Interpolation factor (0.0 to 1.0)\n * @returns Interpolated value\n */\nfunction interpolate(a: number, b: number, t: number): number {\n    return a + t * (b - a);\n}\n\n/**\n * Maps doppler velocity values to RGB colors using a predefined color map\n * @param colorMap The color mapping array (256 RGB values)\n * @param velocities Array of doppler velocity values\n * @param minDoppler Minimum doppler value for normalization (0 = auto)\n * @param maxDoppler Maximum doppler value for normalization (0 = auto)\n * @returns Array of RGB color values corresponding to input velocities\n */\nfunction mapDopplerToRGB(\n    colorMap: number[][],\n    velocities: number[],\n    minDoppler: number,\n    maxDoppler: number,\n): number[][] {\n    // Auto-range if both bounds are set to 0\n    if (minDoppler == 0.0 && maxDoppler == 0.0) {\n        minDoppler = Math.min(...velocities);\n        maxDoppler = Math.max(...velocities);\n    }\n\n    // Ensure min is negative (moving away) and max is positive (moving toward)\n    const minDop = -Math.abs(minDoppler);\n    const maxDop = Math.abs(maxDoppler);\n    const dopplerRange = maxDop - minDop;\n\n    return velocities.map((velocity) => {\n        // Normalize velocity to 0-255 range\n        const normalizedValue = Math.max(\n            0,\n            Math.min(\n                255,\n                Math.round(((velocity - minDop) / dopplerRange) * 255),\n            ),\n        );\n\n        // Return the corresponding color from the map with safe fallback\n        return colorMap[normalizedValue] || [0, 0, 0];\n    });\n}\n\n/**\n * Converts a 4-byte Uint8Array to a Float32 value\n * @param bytes 4-byte Uint8Array containing the float data\n * @returns Parsed float32 value\n */\nfunction uint8ArrayToFloat32(bytes: Uint8Array): number {\n    return new DataView(bytes.buffer).getFloat32(0, true); // true for little-endian\n}\n\n/**\n * Main script function to process point cloud data\n * @param event Input point cloud message\n * @param globalVars User-configurable parameters\n * @returns Processed point cloud with color data\n */\nexport default function script(\n    event: Input<\"/point_cloud\">,\n    globalVars: GlobalVariables,\n): PointCloud {\n    // Define interfaces that match the message structure\n    interface ROS2PointCloudMessage {\n        row_step: number;\n        point_step: number;\n        data: Uint8Array;\n        header: {\n            stamp: {\n                sec: number;\n                nsec: number;\n            };\n            frame_id: string;\n        };\n    }\n\n    interface APIPointCloudMessage {\n        point_stride: number;\n        data: Uint8Array;\n        timestamp: {\n            sec: number;\n            nsec: number;\n        };\n        frame_id: string;\n        fields: any[];\n    }\n\n    // Type guard functions\n    // This is used because TypeScript can't infer the type of the message during compilation, but we can check it at runtime\n    // Ref: https://www.typescriptlang.org/docs/handbook/advanced-types.html#using-the-in-operator\n    function isROS2PointCloud(message: any): message is ROS2PointCloudMessage {\n        return \"row_step\" in message && \"point_step\" in message;\n    }\n\n    function isAPIPointCloud(message: any): message is APIPointCloudMessage {\n        return \"point_stride\" in message;\n    }\n\n    if (isROS2PointCloud(event.message)) {\n        // Process ROS2 point cloud message\n        const {\n            data,\n            point_step: originalStride,\n            header: ros_header,\n        } = event.message;\n\n        return processROS2PointCloud(\n            data,\n            originalStride,\n            ros_header,\n            globalVars,\n        );\n    } else if (isAPIPointCloud(event.message)) {\n        // Process API point cloud message\n        return processAPIPointCloud(event.message, globalVars);\n    } else {\n        throw new Error(\"Unknown point cloud message format\");\n    }\n}\n\n/**\n * Extracts XYZ and doppler values from point cloud data\n * @param data Raw point cloud data\n * @param stride Point stride in bytes\n * @param numPoints Number of points in the cloud\n * @param XYZ_OFFSET Offset of the XYZ fields in bytes\n * @param DOP_OFFSET Offset of the doppler field in bytes\n * @returns Object containing xyz positions and doppler velocities\n */\nfunction extractXYZAndDoppler(\n    data: Uint8Array,\n    stride: number,\n    numPoints: number,\n    XYZ_OFFSET: number,\n    DOP_OFFSET: number,\n): { xyz: Float32Array; dopplerValues: number[] } {\n    const xyz = new Float32Array(numPoints * 3);\n    const dopplerValues: number[] = [];\n\n    for (let i = 0; i < numPoints; i++) {\n        const pointOffset = i * stride;\n\n        // Extract XYZ (12 bytes starting at XYZ_OFFSET)\n        const xyzView = new DataView(\n            data.buffer,\n            data.byteOffset + pointOffset,\n            stride,\n        );\n        xyz[i * 3] = xyzView.getFloat32(XYZ_OFFSET, true); // x\n        xyz[i * 3 + 1] = xyzView.getFloat32(XYZ_OFFSET + 4, true); // y\n        xyz[i * 3 + 2] = xyzView.getFloat32(XYZ_OFFSET + 8, true); // z\n\n        // Extract doppler velocity\n        const dopplerBytes = new Uint8Array(4);\n        dopplerBytes.set(\n            data.subarray(\n                pointOffset + DOP_OFFSET,\n                pointOffset + DOP_OFFSET + 4,\n            ),\n        );\n        dopplerValues.push(uint8ArrayToFloat32(dopplerBytes));\n    }\n\n    return { xyz, dopplerValues };\n}\n\n/**\n * Creates XYZRGBA point cloud from positions and colors\n * @param xyz Float32Array of XYZ positions (length = numPoints * 3)\n * @param colors RGB color values for each point\n * @param numPoints Number of points in the cloud\n * @returns New Uint8Array with XYZRGBA data\n */\nfunction createXYZRGBAPointCloud(\n    xyz: Float32Array,\n    colors: number[][],\n    numPoints: number,\n): Uint8Array {\n    const newSize = numPoints * XYZRGBA_STRIDE;\n    const newData = new Uint8Array(newSize);\n\n    for (let i = 0; i < numPoints; i++) {\n        const offset = i * XYZRGBA_STRIDE;\n\n        // Write XYZ (12 bytes)\n        const xyzView = new DataView(newData.buffer, offset, 12);\n        xyzView.setFloat32(0, xyz[i * 3], true); // x\n        xyzView.setFloat32(4, xyz[i * 3 + 1], true); // y\n        xyzView.setFloat32(8, xyz[i * 3 + 2], true); // z\n\n        // Write RGBA (4 bytes)\n        if (i < colors.length && colors[i]) {\n            const [r, g, b] = colors[i].map((v) =>\n                Math.round(Math.max(0, Math.min(255, v))),\n            );\n            newData[offset + 12] = r;\n            newData[offset + 13] = g;\n            newData[offset + 14] = b;\n            newData[offset + 15] = 255; // alpha\n        } else {\n            // Fallback color if data is missing\n            newData[offset + 12] = 128; // r\n            newData[offset + 13] = 128; // g\n            newData[offset + 14] = 128; // b\n            newData[offset + 15] = 255; // alpha\n        }\n    }\n\n    return newData;\n}\n\n/**\n * Processes a ROS2 PointCloud2 message and adds color information based on Doppler values\n * @param data Point cloud data as Uint8Array\n * @param originalStride Original point stride in bytes\n * @param ros_header ROS2 message header\n * @param globalVars Global variables for Doppler bounds\n * @returns Modified PointCloud message with color information\n */\nfunction processROS2PointCloud(\n    data: Uint8Array,\n    originalStride: number,\n    ros_header: {\n        stamp: {\n            sec: number;\n            nsec: number;\n        };\n        frame_id: string;\n    },\n    globalVars: GlobalVariables,\n) {\n    const XYZ_OFFSET = 0;\n    const DOP_OFFSET = 16;\n    const numPoints = data.length / originalStride;\n\n    // Extract XYZ and Doppler values\n    const { xyz, dopplerValues } = extractXYZAndDoppler(\n        data,\n        originalStride,\n        numPoints,\n        XYZ_OFFSET,\n        DOP_OFFSET,\n    );\n\n    // Map Doppler values to RGB colors\n    const colorMap = createLinearColorMap(DOPPLER_COLORS);\n    const rgbColors = mapDopplerToRGB(\n        colorMap,\n        dopplerValues,\n        globalVars.min_dop_bound,\n        globalVars.max_dop_bound,\n    );\n\n    // Create XYZRGBA point cloud\n    const xyzrgbaData = createXYZRGBAPointCloud(xyz, rgbColors, numPoints);\n\n    // Return the modified point cloud message\n    return {\n        timestamp: {\n            sec: ros_header.stamp.sec,\n            nsec: ros_header.stamp.nsec,\n        },\n        frame_id: ros_header.frame_id,\n        pose: {\n            position: { x: 0, y: 0, z: 0 },\n            orientation: { x: 0, y: 0, z: 0, w: 1 },\n        },\n        point_stride: XYZRGBA_STRIDE,\n        fields: XYZRGBA_FIELDS,\n        data: xyzrgbaData,\n    };\n}\n\n/**\n * Processes an API PointCloud message and adds color information based on Doppler values\n * @param api_message API PointCloud message\n * @param globalVars Global variables for Doppler bounds\n * @returns Modified PointCloud message with color information\n */\nfunction processAPIPointCloud(\n    api_message: {\n        data: Uint8Array;\n        point_stride: number;\n        timestamp: {\n            sec: number;\n            nsec: number;\n        };\n        frame_id: string;\n        fields: any[];\n    },\n    globalVars: GlobalVariables,\n) {\n    const XYZ_OFFSET = 8;\n    const DOP_OFFSET = 20;\n\n    // Get the original point cloud data as a Uint8Array\n    const {\n        data,\n        point_stride: old_strid,\n        timestamp: ts,\n        frame_id: fid,\n    } = api_message;\n\n    const numPoints = Math.floor(data.length / old_strid);\n\n    // Extract XYZ and Doppler values\n    const { xyz, dopplerValues } = extractXYZAndDoppler(\n        data,\n        old_strid,\n        numPoints,\n        XYZ_OFFSET,\n        DOP_OFFSET,\n    );\n\n    // Map the Doppler values to RGB colors\n    const dopplerColors = mapDopplerToRGB(\n        dopColorMap,\n        dopplerValues,\n        globalVars.min_dop_bound,\n        globalVars.max_dop_bound,\n    );\n\n    // Create XYZRGBA point cloud\n    const xyzrgbaData = createXYZRGBAPointCloud(xyz, dopplerColors, numPoints);\n\n    // Return the modified point cloud message\n    return {\n        timestamp: {\n            sec: ts.sec,\n            nsec: ts.nsec,\n        },\n        frame_id: fid,\n        pose: {\n            position: { x: 0, y: 0, z: 0 },\n            orientation: { x: 0, y: 0, z: 0, w: 1 },\n        },\n        point_stride: XYZRGBA_STRIDE,\n        fields: XYZRGBA_FIELDS,\n        data: xyzrgbaData,\n    };\n}\n",
      "name": "dop_color_add_fields.ts"
    },
    "0951bbfe-4683-437a-84e1-102e7f204624": {
      "sourceCode":
          "// Copyright (c) 2024-2025 Voyant Photonics, Inc.\n//\n// This example code is licensed under the MIT License.\n// See the LICENSE file in the repository root for full license text.\n\nimport { Input } from \"./types\";\nimport { PointCloud, PackedElementField } from \"@foxglove/schemas\";\n\nconst COLOR_MAP_SIZE = 255;\nconst MAX_HUE = 360;\nconst MAX_SATURATION = 100;\nconst MAX_VALUE = 100;\nconst ALPHA_MAX = 255;\n\n// The input and output topics for your script\nexport const inputs = [\"/point_cloud\"];\nexport const output = \"/rng_color_pointcloud\";\n\ntype GlobalVariables = {\n    range_band: number;\n};\n\ninterface RGB {\n    r: number;\n    g: number;\n    b: number;\n}\n\n// Output point cloud field structure with XYZRGBA\nconst XYZRGBA_FIELDS: PackedElementField[] = [\n    { name: \"x\", offset: 0, type: 7 }, // FLOAT32\n    { name: \"y\", offset: 4, type: 7 }, // FLOAT32\n    { name: \"z\", offset: 8, type: 7 }, // FLOAT32\n    { name: \"red\", offset: 12, type: 1 }, // UINT8\n    { name: \"green\", offset: 13, type: 1 }, // UINT8\n    { name: \"blue\", offset: 14, type: 1 }, // UINT8\n    { name: \"alpha\", offset: 15, type: 1 }, // UINT8\n];\n\nconst XYZRGBA_STRIDE = 16;\n\n/**\n * Converts HSV color values to RGB\n * @param h - Hue (0-360)\n * @param s - Saturation (0-100)\n * @param v - Value (0-100)\n * @returns RGB color object with values 0-255\n */\nfunction hsvToRgb(h: number, s: number, v: number): RGB {\n    // Normalize values to [0,1] range\n    const hNorm = h / MAX_HUE;\n    const sNorm = s / MAX_SATURATION;\n    const vNorm = v / MAX_VALUE;\n\n    const i = Math.floor(hNorm * 6);\n    const f = hNorm * 6 - i;\n    const p = vNorm * (1 - sNorm);\n    const q = vNorm * (1 - f * sNorm);\n    const t = vNorm * (1 - (1 - f) * sNorm);\n\n    let r = 0,\n        g = 0,\n        b = 0;\n    switch (i % 6) {\n        case 0:\n            r = vNorm;\n            g = t;\n            b = p;\n            break;\n        case 1:\n            r = q;\n            g = vNorm;\n            b = p;\n            break;\n        case 2:\n            r = p;\n            g = vNorm;\n            b = t;\n            break;\n        case 3:\n            r = p;\n            g = q;\n            b = vNorm;\n            break;\n        case 4:\n            r = t;\n            g = p;\n            b = vNorm;\n            break;\n        case 5:\n            r = vNorm;\n            g = p;\n            b = q;\n            break;\n    }\n\n    return {\n        r: Math.round(r * 255),\n        g: Math.round(g * 255),\n        b: Math.round(b * 255),\n    };\n}\n\n/**\n * Creates a cyclic color map with evenly distributed hues\n * @param numColors - Number of colors in the map\n * @param saturation - Saturation value (0-100)\n * @param value - Brightness value (0-100)\n * @returns 2D array of RGB values [r,g,b]\n */\nfunction createCyclicColorMap(\n    numColors: number,\n    saturation: number,\n    value: number,\n): number[][] {\n    const colorMap: number[][] = [];\n\n    for (let i = 0; i < numColors; i++) {\n        const hue = (i / numColors) * MAX_HUE;\n        const { r, g, b } = hsvToRgb(hue, saturation, value);\n        colorMap.push([r, g, b]);\n    }\n\n    return colorMap;\n}\n\n/**\n * Maps range values to RGB colors using the provided color map\n * @param colorMap - 2D array of RGB values\n * @param rangeValues - Array of range values to map\n * @param bandSize - Size of each color band\n * @returns 2D array of RGB values for each input range value\n */\nfunction mapRangeToRgb(\n    colorMap: number[][],\n    rangeValues: number[],\n    bandSize: number,\n): number[][] {\n    // Normalize ranges into bands\n    const normalizedValues = rangeValues.map(\n        (val) => (val % bandSize) / bandSize,\n    );\n\n    // Map normalized values to color indices\n    const colorIndices = normalizedValues.map((val) =>\n        Math.floor(val * (COLOR_MAP_SIZE - 1)),\n    );\n\n    // Return RGB values from the color map\n    return colorIndices.map((index) => {\n        if (index >= 0 && index < colorMap.length) {\n            return colorMap[index];\n        }\n        return [0, 0, 0]; // Fallback for out-of-range indices\n    });\n}\n\n// Create a color map once for reuse\nconst rangeColorMap: number[][] = createCyclicColorMap(\n    COLOR_MAP_SIZE,\n    MAX_SATURATION,\n    MAX_VALUE,\n);\n\n/**\n * Main script function that processes the point cloud data\n * @param event - Input event containing the point cloud message\n * @param globalVars - Global variables including range_band\n * @returns Modified point cloud with color data\n */\nexport default function script(\n    event: Input<\"/point_cloud\">,\n    globalVars: GlobalVariables,\n): PointCloud {\n    // Define interfaces that match the message structure\n    interface ROS2PointCloudMessage {\n        row_step: number;\n        point_step: number;\n        data: Uint8Array;\n        header: {\n            stamp: {\n                sec: number;\n                nsec: number;\n            };\n            frame_id: string;\n        };\n    }\n\n    interface APIPointCloudMessage {\n        point_stride: number;\n        data: Uint8Array;\n        timestamp: {\n            sec: number;\n            nsec: number;\n        };\n        frame_id: string;\n        fields: any[];\n    }\n\n    // Type guard functions\n    // This is used because TypeScript can't infer the type of the message during compilation, but we can check it at runtime\n    // Ref: https://www.typescriptlang.org/docs/handbook/advanced-types.html#using-the-in-operator\n    function isROS2PointCloud(message: any): message is ROS2PointCloudMessage {\n        return \"row_step\" in message && \"point_step\" in message;\n    }\n\n    function isAPIPointCloud(message: any): message is APIPointCloudMessage {\n        return \"point_stride\" in message;\n    }\n\n    if (isROS2PointCloud(event.message)) {\n        // Process ROS2 point cloud message\n        const {\n            data,\n            point_step: originalStride,\n            header: ros_header,\n        } = event.message;\n\n        return processROS2PointCloud(\n            data,\n            originalStride,\n            ros_header,\n            globalVars,\n        );\n    } else if (isAPIPointCloud(event.message)) {\n        // Process API point cloud message\n        return processAPIPointCloud(event.message, globalVars);\n    } else {\n        throw new Error(\"Unknown point cloud message format\");\n    }\n}\n\n/**\n * Extracts XYZ and range values from point cloud data\n * \"Range\" is actually just the x axis value\n * @param data Raw point cloud data\n * @param stride Point stride in bytes\n * @param numPoints Number of points in the cloud\n * @param XYZ_OFFSET Offset of the XYZ fields in bytes\n * @returns Object containing xyz positions and range values\n */\nfunction extractXYZAndRange(\n    data: Uint8Array,\n    stride: number,\n    numPoints: number,\n    XYZ_OFFSET: number,\n): { xyz: Float32Array; rangeValues: number[] } {\n    const xyz = new Float32Array(numPoints * 3);\n    const rangeValues: number[] = [];\n\n    for (let i = 0; i < numPoints; i++) {\n        const pointOffset = i * stride;\n\n        // Extract XYZ (12 bytes starting at XYZ_OFFSET)\n        const xyzView = new DataView(\n            data.buffer,\n            data.byteOffset + pointOffset,\n            stride,\n        );\n        const x = xyzView.getFloat32(XYZ_OFFSET, true);\n        const y = xyzView.getFloat32(XYZ_OFFSET + 4, true);\n        const z = xyzView.getFloat32(XYZ_OFFSET + 8, true);\n\n        xyz[i * 3] = x;\n        xyz[i * 3 + 1] = y;\n        xyz[i * 3 + 2] = z;\n\n        // Calculate range\n        rangeValues.push(x);\n    }\n\n    return { xyz, rangeValues };\n}\n\n/**\n * Creates XYZRGBA point cloud from positions and colors\n * @param xyz Float32Array of XYZ positions (length = numPoints * 3)\n * @param colors RGB color values for each point\n * @param numPoints Number of points in the cloud\n * @returns New Uint8Array with XYZRGBA data\n */\nfunction createXYZRGBAPointCloud(\n    xyz: Float32Array,\n    colors: number[][],\n    numPoints: number,\n): Uint8Array {\n    const newSize = numPoints * XYZRGBA_STRIDE;\n    const newData = new Uint8Array(newSize);\n\n    for (let i = 0; i < numPoints; i++) {\n        const offset = i * XYZRGBA_STRIDE;\n\n        // Write XYZ (12 bytes)\n        const xyzView = new DataView(newData.buffer, offset, 12);\n        xyzView.setFloat32(0, xyz[i * 3], true); // x\n        xyzView.setFloat32(4, xyz[i * 3 + 1], true); // y\n        xyzView.setFloat32(8, xyz[i * 3 + 2], true); // z\n\n        // Write RGBA (4 bytes)\n        const color = i < colors.length ? colors[i] : [0, 0, 0];\n        newData[offset + 12] = color[0] || 0; // r\n        newData[offset + 13] = color[1] || 0; // g\n        newData[offset + 14] = color[2] || 0; // b\n        newData[offset + 15] = ALPHA_MAX; // alpha\n    }\n\n    return newData;\n}\n\n/**\n * Processes a ROS2 PointCloud2 message and adds color information based on range values\n * @param data Point cloud data as Uint8Array\n * @param originalStride Original point stride in bytes\n * @param ros_header ROS2 message header\n * @param globalVars Global variables for range bounds\n * @returns Modified PointCloud message with color information\n */\nfunction processROS2PointCloud(\n    data: Uint8Array,\n    originalStride: number,\n    ros_header: {\n        stamp: {\n            sec: number;\n            nsec: number;\n        };\n        frame_id: string;\n    },\n    globalVars: GlobalVariables,\n) {\n    const XYZ_OFFSET = 0;\n    const numPoints = Math.floor(data.length / originalStride);\n\n    // Extract XYZ and range values\n    const { xyz, rangeValues } = extractXYZAndRange(\n        data,\n        originalStride,\n        numPoints,\n        XYZ_OFFSET,\n    );\n\n    // Map range values to colors\n    const colorValues = mapRangeToRgb(\n        rangeColorMap,\n        rangeValues,\n        globalVars.range_band,\n    );\n\n    // Create XYZRGBA point cloud\n    const xyzrgbaData = createXYZRGBAPointCloud(xyz, colorValues, numPoints);\n\n    // Return the modified point cloud message\n    return {\n        timestamp: {\n            sec: ros_header.stamp.sec,\n            nsec: ros_header.stamp.nsec,\n        },\n        frame_id: ros_header.frame_id,\n        pose: {\n            position: { x: 0, y: 0, z: 0 },\n            orientation: { x: 0, y: 0, z: 0, w: 1 },\n        },\n        point_stride: XYZRGBA_STRIDE,\n        fields: XYZRGBA_FIELDS,\n        data: xyzrgbaData,\n    };\n}\n\n/**\n * Processes an API PointCloud message and adds color information based on range values\n * @param api_message API PointCloud message\n * @param globalVars Global variables for range bounds\n * @returns Modified PointCloud message with color information\n */\nfunction processAPIPointCloud(\n    api_message: {\n        data: Uint8Array;\n        point_stride: number;\n        timestamp: {\n            sec: number;\n            nsec: number;\n        };\n        frame_id: string;\n        fields: any[];\n    },\n    globalVars: GlobalVariables,\n) {\n    const XYZ_OFFSET = 8;\n    const { data, point_stride: old_strid } = api_message;\n    const numPoints = Math.floor(data.length / old_strid);\n\n    // Extract XYZ and range values\n    const { xyz, rangeValues } = extractXYZAndRange(\n        data,\n        old_strid,\n        numPoints,\n        XYZ_OFFSET,\n    );\n\n    // Map range values to colors\n    const colorValues = mapRangeToRgb(\n        rangeColorMap,\n        rangeValues,\n        globalVars.range_band,\n    );\n\n    // Create XYZRGBA point cloud\n    const xyzrgbaData = createXYZRGBAPointCloud(xyz, colorValues, numPoints);\n\n    // Return the modified point cloud message\n    return {\n        timestamp: {\n            sec: api_message.timestamp.sec,\n            nsec: api_message.timestamp.nsec,\n        },\n        frame_id: api_message.frame_id,\n        pose: {\n            position: { x: 0, y: 0, z: 0 },\n            orientation: { x: 0, y: 0, z: 0, w: 1 },\n        },\n        point_stride: XYZRGBA_STRIDE,\n        fields: XYZRGBA_FIELDS,\n        data: xyzrgbaData,\n    };\n}\n",
      "name": "rng_color_add_fields.ts"
    },
    "a1b2c3d4-e5f6-7890-abcd-ef1234567890": {
      "sourceCode":
          "// Copyright (c) 2024-2025 Voyant Photonics, Inc.\n//\n// This example code is licensed under the MIT License.\n// See the LICENSE file in the repository root for full license text.\n\nimport { Input } from \"./types\";\nimport { PointCloud, PackedElementField } from \"@foxglove/schemas\";\n\n// The input and output topics for your script\nexport const inputs = [\"/point_cloud\"];\nexport const output = \"/ref_color_pointcloud\";\n\ntype GlobalVariables = {\n    min_ref_bound: number;\n    max_ref_bound: number;\n};\n\n// Reflectance color configuration (same as SNR)\nconst REF_COLORS: [number, number, number][] = [\n    [7, 107, 236], // Low reflectance (blue)\n    [255, 0, 127], // Mid reflectance (magenta)\n    [255, 204, 0], // High reflectance (yellow)\n];\n\n// Pre-compute the color map\nconst colorMap = createLinearColorMap(REF_COLORS);\n\n// Output point cloud field structure with XYZRGBA\nconst XYZRGBA_FIELDS: PackedElementField[] = [\n    { name: \"x\", offset: 0, type: 7 }, // FLOAT32\n    { name: \"y\", offset: 4, type: 7 }, // FLOAT32\n    { name: \"z\", offset: 8, type: 7 }, // FLOAT32\n    { name: \"red\", offset: 12, type: 1 }, // UINT8\n    { name: \"green\", offset: 13, type: 1 }, // UINT8\n    { name: \"blue\", offset: 14, type: 1 }, // UINT8\n    { name: \"alpha\", offset: 15, type: 1 }, // UINT8\n];\n\nconst XYZRGBA_STRIDE = 16;\n\n// Fallback gray color for points without reflectance data\nconst FALLBACK_COLOR: number[] = [128, 128, 128];\n\n/**\n * Creates a linear color mapping between three colors\n * @param colors Array of three [r,g,b] colors representing low, mid, and high values\n * @returns A 256-entry color map with interpolated values\n */\nfunction createLinearColorMap(colors: [number, number, number][]): number[][] {\n    if (colors.length !== 3) {\n        throw new Error(\"Color map requires exactly 3 colors (low, mid, high)\");\n    }\n\n    const [colorLow, colorMid, colorHigh] = colors;\n    const colorMap: number[][] = [];\n\n    // Create 256 interpolated colors\n    for (let i = 0; i < 256; i++) {\n        const normVal = i / 255;\n        let r, g, b;\n\n        if (normVal < 0.5) {\n            // Interpolate between low and mid colors\n            const factor = normVal * 2;\n            r = colorLow[0] + factor * (colorMid[0] - colorLow[0]);\n            g = colorLow[1] + factor * (colorMid[1] - colorLow[1]);\n            b = colorLow[2] + factor * (colorMid[2] - colorLow[2]);\n        } else {\n            // Interpolate between mid and high colors\n            const factor = (normVal - 0.5) * 2;\n            r = colorMid[0] + factor * (colorHigh[0] - colorMid[0]);\n            g = colorMid[1] + factor * (colorHigh[1] - colorMid[1]);\n            b = colorMid[2] + factor * (colorHigh[2] - colorMid[2]);\n        }\n\n        colorMap.push([Math.round(r), Math.round(g), Math.round(b)]);\n    }\n\n    return colorMap;\n}\n\n/**\n * Converts reflectance values to RGB colors using the provided color map\n * @param colorMap The color map to use for conversion\n * @param refValues Array of reflectance values (in dB)\n * @param minRef Minimum reflectance value for normalization (0 = auto)\n * @param maxRef Maximum reflectance value for normalization (0 = auto)\n * @returns Array of RGB values corresponding to the input reflectance values\n */\nfunction mapRefToRgb(\n    colorMap: number[][],\n    refValues: number[],\n    minRef: number,\n    maxRef: number,\n): number[][] {\n    // Auto-range if both bounds are set to 0\n    if (minRef == 0.0 && maxRef == 0.0) {\n        minRef = Math.min(...refValues);\n        maxRef = Math.max(...refValues);\n    }\n\n    // Find actual min/max within bounds\n    const validMin = Math.max(minRef, Math.min(...refValues));\n    const validMax = Math.min(maxRef, Math.max(...refValues));\n    const range = validMax - validMin;\n\n    return refValues.map((value) => {\n        // Clip to min/max bounds\n        const clippedValue = Math.min(Math.max(value, validMin), validMax);\n\n        // Normalize to 0-255 range\n        const normalizedValue =\n            range === 0\n                ? 128 // Default to middle value if range is zero\n                : ((clippedValue - validMin) / range) * 255;\n\n        // Get color map index (ensuring it's within bounds)\n        const index = Math.min(Math.max(Math.round(normalizedValue), 0), 255);\n\n        return colorMap[index];\n    });\n}\n\n/**\n * Converts a 4-byte Uint8Array to a Float32 value\n * @param bytes 4-byte Uint8Array\n * @returns Float32 value\n */\nfunction bytesToFloat32(bytes: Uint8Array): number {\n    const dataView = new DataView(bytes.buffer, bytes.byteOffset, 4);\n    return dataView.getFloat32(0, true); // true for little-endian\n}\n\n/**\n * Safely converts a linear value to dB scale\n * @param val Linear value\n * @returns dB value, or -100 for zero/negative values\n */\nfunction safeLog10dB(val: number): number {\n    if (val > 0) {\n        return 10 * Math.log10(val);\n    }\n    return -100;\n}\n\n/**\n * Main script function to process point cloud data and color it based on reflectance values\n * @param event Input event containing LiDAR point cloud data\n * @param globalVars Global variables for reflectance bounds\n * @returns Modified point cloud with added color information\n */\nexport default function script(\n    event: Input<\"/point_cloud\">,\n    globalVars: GlobalVariables,\n): PointCloud {\n    // Define interfaces that match the message structure\n    interface ROS2PointCloudMessage {\n        row_step: number;\n        point_step: number;\n        data: Uint8Array;\n        header: {\n            stamp: {\n                sec: number;\n                nsec: number;\n            };\n            frame_id: string;\n        };\n    }\n\n    interface APIPointCloudMessage {\n        point_stride: number;\n        data: Uint8Array;\n        timestamp: {\n            sec: number;\n            nsec: number;\n        };\n        frame_id: string;\n        fields: any[];\n    }\n\n    // Type guard functions\n    // This is used because TypeScript can't infer the type of the message during compilation, but we can check it at runtime\n    // Ref: https://www.typescriptlang.org/docs/handbook/advanced-types.html#using-the-in-operator\n    function isROS2PointCloud(message: any): message is ROS2PointCloudMessage {\n        return \"row_step\" in message && \"point_step\" in message;\n    }\n\n    function isAPIPointCloud(message: any): message is APIPointCloudMessage {\n        return \"point_stride\" in message;\n    }\n\n    if (isROS2PointCloud(event.message)) {\n        // Process ROS2 point cloud message\n        const {\n            data,\n            point_step: originalStride,\n            header: ros_header,\n        } = event.message;\n\n        return processROS2PointCloud(\n            data,\n            originalStride,\n            ros_header,\n            globalVars,\n        );\n    } else if (isAPIPointCloud(event.message)) {\n        // Process API point cloud message\n        return processAPIPointCloud(event.message, globalVars);\n    } else {\n        throw new Error(\"Unknown point cloud message format\");\n    }\n}\n\n/**\n * Extracts XYZ and reflectance values from point cloud data\n * @param data Raw point cloud data\n * @param stride Point stride in bytes\n * @param numPoints Number of points in the cloud\n * @param XYZ_OFFSET Offset of the XYZ fields in bytes\n * @param REF_OFFSET Offset of the reflectance field in bytes\n * @returns Object containing xyz positions and reflectance values\n */\nfunction extractXYZAndReflectance(\n    data: Uint8Array,\n    stride: number,\n    numPoints: number,\n    XYZ_OFFSET: number,\n    REF_OFFSET: number,\n): { xyz: Float32Array; refValues: number[] } {\n    const xyz = new Float32Array(numPoints * 3);\n    const refValues: number[] = [];\n\n    for (let i = 0; i < numPoints; i++) {\n        const pointOffset = i * stride;\n\n        // Extract XYZ (12 bytes starting at XYZ_OFFSET)\n        const xyzView = new DataView(\n            data.buffer,\n            data.byteOffset + pointOffset,\n            stride,\n        );\n        xyz[i * 3] = xyzView.getFloat32(XYZ_OFFSET, true); // x\n        xyz[i * 3 + 1] = xyzView.getFloat32(XYZ_OFFSET + 4, true); // y\n        xyz[i * 3 + 2] = xyzView.getFloat32(XYZ_OFFSET + 8, true); // z\n\n        // Extract reflectance and convert to dB\n        const refBytes = data.slice(\n            pointOffset + REF_OFFSET,\n            pointOffset + REF_OFFSET + 4,\n        );\n        const refValue = bytesToFloat32(refBytes);\n        // Safely convert to dB scale\n        const refDb = safeLog10dB(refValue);\n        refValues.push(refDb);\n    }\n\n    return { xyz, refValues };\n}\n\n/**\n * Extracts only XYZ values from point cloud data (for non-reflectance formats)\n * @param data Raw point cloud data\n * @param stride Point stride in bytes\n * @param numPoints Number of points in the cloud\n * @param XYZ_OFFSET Offset of the XYZ fields in bytes\n * @returns Float32Array of XYZ positions\n */\nfunction extractXYZOnly(\n    data: Uint8Array,\n    stride: number,\n    numPoints: number,\n    XYZ_OFFSET: number,\n): Float32Array {\n    const xyz = new Float32Array(numPoints * 3);\n\n    for (let i = 0; i < numPoints; i++) {\n        const pointOffset = i * stride;\n\n        // Extract XYZ (12 bytes starting at XYZ_OFFSET)\n        const xyzView = new DataView(\n            data.buffer,\n            data.byteOffset + pointOffset,\n            stride,\n        );\n        xyz[i * 3] = xyzView.getFloat32(XYZ_OFFSET, true); // x\n        xyz[i * 3 + 1] = xyzView.getFloat32(XYZ_OFFSET + 4, true); // y\n        xyz[i * 3 + 2] = xyzView.getFloat32(XYZ_OFFSET + 8, true); // z\n    }\n\n    return xyz;\n}\n\n/**\n * Creates XYZRGBA point cloud from positions and colors\n * @param xyz Float32Array of XYZ positions (length = numPoints * 3)\n * @param colors RGB color values for each point\n * @param numPoints Number of points in the cloud\n * @returns New Uint8Array with XYZRGBA data\n */\nfunction createXYZRGBAPointCloud(\n    xyz: Float32Array,\n    colors: number[][],\n    numPoints: number,\n): Uint8Array {\n    const newSize = numPoints * XYZRGBA_STRIDE;\n    const newData = new Uint8Array(newSize);\n\n    for (let i = 0; i < numPoints; i++) {\n        const offset = i * XYZRGBA_STRIDE;\n\n        // Write XYZ (12 bytes)\n        const xyzView = new DataView(newData.buffer, offset, 12);\n        xyzView.setFloat32(0, xyz[i * 3], true); // x\n        xyzView.setFloat32(4, xyz[i * 3 + 1], true); // y\n        xyzView.setFloat32(8, xyz[i * 3 + 2], true); // z\n\n        // Write RGBA (4 bytes)\n        if (i < colors.length && colors[i]) {\n            const [r, g, b] = colors[i].map((v) =>\n                Math.round(Math.max(0, Math.min(255, v))),\n            );\n            newData[offset + 12] = r;\n            newData[offset + 13] = g;\n            newData[offset + 14] = b;\n            newData[offset + 15] = 255; // alpha\n        } else {\n            // Fallback color if data is missing\n            newData[offset + 12] = 128; // r\n            newData[offset + 13] = 128; // g\n            newData[offset + 14] = 128; // b\n            newData[offset + 15] = 255; // alpha\n        }\n    }\n\n    return newData;\n}\n\n/**\n * Processes a ROS2 PointCloud2 message and adds color information based on reflectance values\n * @param data Point cloud data as Uint8Array\n * @param originalStride Original point stride in bytes\n * @param ros_header ROS2 message header\n * @param globalVars Global variables for reflectance bounds\n * @returns Modified PointCloud message with color information\n */\nfunction processROS2PointCloud(\n    data: Uint8Array,\n    originalStride: number,\n    ros_header: {\n        stamp: {\n            sec: number;\n            nsec: number;\n        };\n        frame_id: string;\n    },\n    globalVars: GlobalVariables,\n) {\n    const XYZ_OFFSET = 0;\n    const REF_OFFSET = 36;\n    const VOYANT_POINT_STRIDE = 48; // Standard VoyantPoint without reflectance\n    const numPoints = data.length / originalStride;\n\n    // Check if this is the extended format with reflectance\n    // Only VoyantPointMdlExtended (stride > 48) has reflectance data\n    const hasReflectance = originalStride > VOYANT_POINT_STRIDE;\n\n    let xyz: Float32Array;\n    let rgbColors: number[][];\n\n    if (hasReflectance) {\n        // Extract XYZ and reflectance values\n        const result = extractXYZAndReflectance(\n            data,\n            originalStride,\n            numPoints,\n            XYZ_OFFSET,\n            REF_OFFSET,\n        );\n        xyz = result.xyz;\n\n        // Convert reflectance values to RGB colors\n        rgbColors = mapRefToRgb(\n            colorMap,\n            result.refValues,\n            globalVars.min_ref_bound,\n            globalVars.max_ref_bound,\n        );\n    } else {\n        // No reflectance data - extract only XYZ and use fallback gray for all points\n        xyz = extractXYZOnly(data, originalStride, numPoints, XYZ_OFFSET);\n        rgbColors = Array(numPoints).fill(FALLBACK_COLOR);\n    }\n\n    // Create the new point cloud data with added color information\n    const coloredPointCloud = createXYZRGBAPointCloud(\n        xyz,\n        rgbColors,\n        numPoints,\n    );\n\n    // Return the modified point cloud message\n    return {\n        timestamp: {\n            sec: ros_header.stamp.sec,\n            nsec: ros_header.stamp.nsec,\n        },\n        frame_id: ros_header.frame_id,\n        pose: {\n            position: { x: 0, y: 0, z: 0 },\n            orientation: { x: 0, y: 0, z: 0, w: 1 },\n        },\n        point_stride: XYZRGBA_STRIDE,\n        fields: XYZRGBA_FIELDS,\n        data: coloredPointCloud,\n    };\n}\n\n/**\n * Processes an API PointCloud message and adds color information based on reflectance values\n * API messages always have reflectance data available\n * @param api_message API PointCloud message\n * @param globalVars Global variables for reflectance bounds\n * @returns Modified PointCloud message with color information\n */\nfunction processAPIPointCloud(\n    api_message: {\n        data: Uint8Array;\n        point_stride: number;\n        timestamp: {\n            sec: number;\n            nsec: number;\n        };\n        frame_id: string;\n        fields: any[];\n    },\n    globalVars: GlobalVariables,\n) {\n    const XYZ_OFFSET = 8;\n    const REF_OFFSET = 28;\n\n    // Get the original point cloud data as a Uint8Array\n    const {\n        data,\n        point_stride: old_strid,\n        timestamp: ts,\n        frame_id: fid,\n    } = api_message;\n\n    const numPoints = Math.floor(data.length / old_strid);\n\n    // Extract XYZ and reflectance values (always available in API messages)\n    const { xyz, refValues } = extractXYZAndReflectance(\n        data,\n        old_strid,\n        numPoints,\n        XYZ_OFFSET,\n        REF_OFFSET,\n    );\n\n    // Convert reflectance values to RGB colors\n    const rgbColors = mapRefToRgb(\n        colorMap,\n        refValues,\n        globalVars.min_ref_bound,\n        globalVars.max_ref_bound,\n    );\n\n    // Create the new point cloud data with added color information\n    const coloredPointCloud = createXYZRGBAPointCloud(\n        xyz,\n        rgbColors,\n        numPoints,\n    );\n\n    // Return the modified point cloud message\n    return {\n        timestamp: {\n            sec: ts.sec,\n            nsec: ts.nsec,\n        },\n        frame_id: fid,\n        pose: {\n            position: { x: 0, y: 0, z: 0 },\n            orientation: { x: 0, y: 0, z: 0, w: 1 },\n        },\n        point_stride: XYZRGBA_STRIDE,\n        fields: XYZRGBA_FIELDS,\n        data: coloredPointCloud,\n    };\n}\n",
      "name": "ref_color_add_fields.ts"
    }
  },
  "playbackConfig": {
    "speed": 1
  },
  "layout": {
    "first": {
      "first": {
        "first": "3D!3cvisw1",
        "second": "3D!1pnxa9v",
        "direction": "column",
        "splitPercentage": 50
      },
      "second": {
        "first": "3D!16ej2nv",
        "second": "3D!1sbddfc",
        "direction": "column",
        "splitPercentage": 50
      },
      "direction": "row",
      "splitPercentage": 50
    },
    "second": {
      "first": "GlobalVariableSliderPanel!3q2vfoj",
      "second": {
        "first": "GlobalVariableSliderPanel!2gxsope",
        "second": {
          "first": "GlobalVariableSliderPanel!5wqrfj",
          "second": {
            "first": "GlobalVariableSliderPanel!6ref01",
            "second": {
              "first": "GlobalVariableSliderPanel!6ref02",
              "second": {
                "first": "GlobalVariableSliderPanel!3qbvnjm",
                "second": "GlobalVariableSliderPanel!2e7ijri",
                "direction": "column",
                "splitPercentage": 50
              },
              "direction": "column",
              "splitPercentage": 33.333333333333336
            },
            "direction": "column",
            "splitPercentage": 25
          },
          "direction": "column",
          "splitPercentage": 20
        },
        "direction": "column",
        "splitPercentage": 16.666666666666668
      },
      "direction": "column",
      "splitPercentage": 14.285714285714286
    },
    "direction": "row",
    "splitPercentage": 85
  }
}
