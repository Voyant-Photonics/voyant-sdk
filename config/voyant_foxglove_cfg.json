{
  "configById": {
    "3D!e6sz0o": {
      "cameraState": {
        "distance": 12.604988194492108,
        "perspective": true,
        "phi": 59.99999999999992,
        "target": [
          0,
          0,
          0
        ],
        "targetOffset": [
          0,
          0,
          0
        ],
        "targetOrientation": [
          0,
          0,
          0,
          1
        ],
        "thetaOffset": 44.99999999999999,
        "fovy": 45,
        "near": 0.5,
        "far": 5000
      },
      "followMode": "follow-pose",
      "scene": {},
      "transforms": {},
      "topics": {
        "/rng_color_pointcloud": {
          "visible": true,
          "colorField": "x",
          "colorMode": "rgba-fields",
          "colorMap": "turbo",
          "pointSize": 2
        }
      },
      "layers": {
        "grid": {
          "visible": false,
          "frameLocked": true,
          "label": "Grid",
          "instanceId": "058bda43-3c84-451b-b782-d01d4a53c085",
          "layerId": "foxglove.Grid",
          "size": 10,
          "divisions": 10,
          "lineWidth": 1,
          "color": "#248eff",
          "position": [
            0,
            0,
            0
          ],
          "rotation": [
            0,
            0,
            0
          ]
        }
      },
      "publish": {
        "type": "point",
        "poseTopic": "/move_base_simple/goal",
        "pointTopic": "/clicked_point",
        "poseEstimateTopic": "/initialpose",
        "poseEstimateXDeviation": 0.5,
        "poseEstimateYDeviation": 0.5,
        "poseEstimateThetaDeviation": 0.26179939
      },
      "imageMode": {}
    },
    "3D!1pnxa9v": {
      "cameraState": {
        "distance": 12.604988194492108,
        "perspective": true,
        "phi": 59.99999999999992,
        "target": [
          0,
          0,
          0
        ],
        "targetOffset": [
          0,
          0,
          0
        ],
        "targetOrientation": [
          0,
          0,
          0,
          1
        ],
        "thetaOffset": 44.99999999999999,
        "fovy": 45,
        "near": 0.5,
        "far": 5000
      },
      "followMode": "follow-pose",
      "scene": {},
      "transforms": {},
      "topics": {
        "/point_cloud": {
          "visible": false,
          "colorField": "x",
          "colorMode": "flat",
          "colorMap": "rainbow"
        },
        "/dop_color_pointcloud": {
          "visible": true,
          "colorField": "z",
          "colorMode": "rgba-fields",
          "colorMap": "turbo",
          "pointShape": "square",
          "pointSize": 2
        }
      },
      "layers": {
        "grid": {
          "visible": false,
          "frameLocked": true,
          "label": "Grid",
          "instanceId": "8afeb711-8619-4657-815b-25b1b1ea6822",
          "layerId": "foxglove.Grid",
          "size": 10,
          "divisions": 10,
          "lineWidth": 1,
          "color": "#248eff",
          "position": [
            0,
            0,
            0
          ],
          "rotation": [
            0,
            0,
            0
          ]
        }
      },
      "publish": {
        "type": "point",
        "poseTopic": "/move_base_simple/goal",
        "pointTopic": "/clicked_point",
        "poseEstimateTopic": "/initialpose",
        "poseEstimateXDeviation": 0.5,
        "poseEstimateYDeviation": 0.5,
        "poseEstimateThetaDeviation": 0.26179939
      },
      "imageMode": {}
    },
    "3D!1sbddfc": {
      "cameraState": {
        "distance": 12.604988194492108,
        "perspective": true,
        "phi": 59.99999999999992,
        "target": [
          0,
          0,
          0
        ],
        "targetOffset": [
          0,
          0,
          0
        ],
        "targetOrientation": [
          0,
          0,
          0,
          1
        ],
        "thetaOffset": 44.99999999999999,
        "fovy": 45,
        "near": 0.5,
        "far": 5000
      },
      "followMode": "follow-pose",
      "scene": {},
      "transforms": {},
      "topics": {
        "/snr_color_pointcloud": {
          "visible": true,
          "colorField": "z",
          "colorMode": "rgba-fields",
          "colorMap": "turbo",
          "pointSize": 2
        },
        "/dop_color_pointcloud": {
          "visible": false,
          "colorField": "z",
          "colorMode": "rgba-fields",
          "colorMap": "turbo"
        }
      },
      "layers": {
        "grid": {
          "visible": false,
          "frameLocked": true,
          "label": "Grid",
          "instanceId": "8afeb711-8619-4657-815b-25b1b1ea6822",
          "layerId": "foxglove.Grid",
          "size": 10,
          "divisions": 10,
          "lineWidth": 1,
          "color": "#248eff",
          "position": [
            0,
            0,
            0
          ],
          "rotation": [
            0,
            0,
            0
          ]
        }
      },
      "publish": {
        "type": "point",
        "poseTopic": "/move_base_simple/goal",
        "pointTopic": "/clicked_point",
        "poseEstimateTopic": "/initialpose",
        "poseEstimateXDeviation": 0.5,
        "poseEstimateYDeviation": 0.5,
        "poseEstimateThetaDeviation": 0.26179939
      },
      "imageMode": {}
    },
    "GlobalVariableSliderPanel!2e7ijri": {
      "sliderProps": {
        "min": 0,
        "max": 100,
        "step": 0.1
      },
      "globalVariableName": "max_snr_bound",
      "foxglovePanelTitle": "SNR Max Bound (dB)"
    },
    "GlobalVariableSliderPanel!3qbvnjm": {
      "sliderProps": {
        "min": 0,
        "max": 100,
        "step": 0.1
      },
      "globalVariableName": "min_snr_bound",
      "foxglovePanelTitle": "SNR Min Bound (dB)"
    },
    "GlobalVariableSliderPanel!3q2vfoj": {
      "sliderProps": {
        "min": 5,
        "max": 200,
        "step": 0.5
      },
      "globalVariableName": "range_band",
      "foxglovePanelTitle": "Range Band (m)"
    },
    "GlobalVariableSliderPanel!2gxsope": {
      "sliderProps": {
        "min": 0,
        "max": 3,
        "step": 0.1
      },
      "globalVariableName": "min_dop_bound",
      "foxglovePanelTitle": "Doppler Min bound -ve(m/s)"
    },
    "GlobalVariableSliderPanel!5wqrfj": {
      "sliderProps": {
        "min": 0,
        "max": 3,
        "step": 0.1
      },
      "globalVariableName": "max_dop_bound",
      "foxglovePanelTitle": "Doppler Max bound (m/s)"
    },
    "3D!3dztaq2": {
      "cameraState": {
        "perspective": true,
        "distance": 13.966745921874626,
        "phi": 59.999999999999744,
        "thetaOffset": 45.00000000000003,
        "targetOffset": [
          0.4621109997597478,
          -1.076336794632996,
          -2.284937427078791e-17
        ],
        "target": [
          0,
          0,
          0
        ],
        "targetOrientation": [
          0,
          0,
          0,
          1
        ],
        "fovy": 45,
        "near": 0.5,
        "far": 5000
      },
      "followMode": "follow-pose",
      "scene": {},
      "transforms": {},
      "topics": {
        "/point_cloud": {
          "visible": true,
          "colorField": "z",
          "colorMode": "flat",
          "colorMap": "turbo",
          "flatColor": "#ffffffff",
          "pointSize": 2
        }
      },
      "layers": {
        "grid": {
          "visible": false,
          "frameLocked": true,
          "label": "Grid",
          "instanceId": "97612d9a-3be9-43e7-93e3-b4d4100ac048",
          "layerId": "foxglove.Grid",
          "size": 10,
          "divisions": 10,
          "lineWidth": 1,
          "color": "#248eff",
          "position": [
            0,
            0,
            0
          ],
          "rotation": [
            0,
            0,
            0
          ]
        }
      },
      "publish": {
        "type": "point",
        "poseTopic": "/move_base_simple/goal",
        "pointTopic": "/clicked_point",
        "poseEstimateTopic": "/initialpose",
        "poseEstimateXDeviation": 0.5,
        "poseEstimateYDeviation": 0.5,
        "poseEstimateThetaDeviation": 0.26179939
      },
      "imageMode": {}
    }
  },
  "globalVariables": {
    "globalVariable": 2,
    "min_SNR_bound": 5,
    "min_snr_bound": 4,
    "max_snr_bound": 30,
    "min_dop_bound": 0.5,
    "max_dop_bound": 0.5,
    "range_band": 5
  },
  "userNodes": {
    "869d30d4-e1a0-4e9f-aea6-f6dc80f4858a": {
      "sourceCode": "// Copyright (c) 2024-2025 Voyant Photonics, Inc.\n// All rights reserved.\n\nimport { Input } from \"./types\";\nimport { PointCloud } from \"@foxglove/schemas\";\n\n// The input and output topics for your script\nexport const inputs = [\"/point_cloud\"];\nexport const output = \"/snr_color_pointcloud\";\n\ntype GlobalVariables = {\n  min_snr_bound: number;\n  max_snr_bound: number;\n};\n\n// SNR color configuration\nconst SNR_COLORS: [number, number, number][] = [\n  [7, 107, 236], // Low SNR (blue)\n  [255, 0, 127], // Mid SNR (magenta)\n  [255, 204, 0], // High SNR (yellow)\n];\n\n/**\n * Creates a linear color mapping between three colors\n * @param colors Array of three [r,g,b] colors representing low, mid, and high values\n * @returns A 256-entry color map with interpolated values\n */\nfunction createLinearColorMap(colors: [number, number, number][]): number[][] {\n  if (colors.length !== 3) {\n    throw new Error(\"Color map requires exactly 3 colors (low, mid, high)\");\n  }\n\n  const [colorLow, colorMid, colorHigh] = colors;\n  const colorMap: number[][] = [];\n\n  // Create 256 interpolated colors\n  for (let i = 0; i < 256; i++) {\n    const normVal = i / 255;\n    let r, g, b;\n\n    if (normVal < 0.5) {\n      // Interpolate between low and mid colors\n      const factor = normVal * 2;\n      r = colorLow[0] + factor * (colorMid[0] - colorLow[0]);\n      g = colorLow[1] + factor * (colorMid[1] - colorLow[1]);\n      b = colorLow[2] + factor * (colorMid[2] - colorLow[2]);\n    } else {\n      // Interpolate between mid and high colors\n      const factor = (normVal - 0.5) * 2;\n      r = colorMid[0] + factor * (colorHigh[0] - colorMid[0]);\n      g = colorMid[1] + factor * (colorHigh[1] - colorMid[1]);\n      b = colorMid[2] + factor * (colorHigh[2] - colorMid[2]);\n    }\n\n    colorMap.push([Math.round(r), Math.round(g), Math.round(b)]);\n  }\n\n  return colorMap;\n}\n\n/**\n * Converts SNR values to RGB colors using the provided color map\n * @param colorMap The color map to use for conversion\n * @param snrValues Array of SNR values\n * @param minSnr Minimum SNR value for normalization\n * @param maxSnr Maximum SNR value for normalization\n * @returns Array of RGB values corresponding to the input SNR values\n */\nfunction mapSnrToRgb(\n  colorMap: number[][],\n  snrValues: number[],\n  minSnr: number,\n  maxSnr: number,\n): number[][] {\n  // Find actual min/max within bounds\n  const validMin = Math.max(minSnr, Math.min(...snrValues));\n  const validMax = Math.min(maxSnr, Math.max(...snrValues));\n  const range = validMax - validMin;\n\n  return snrValues.map((value) => {\n    // Clip to min/max bounds\n    const clippedValue = Math.min(Math.max(value, validMin), validMax);\n\n    // Normalize to 0-255 range\n    const normalizedValue =\n      range === 0\n        ? 128 // Default to middle value if range is zero\n        : ((clippedValue - validMin) / range) * 255;\n\n    // Get color map index (ensuring it's within bounds)\n    const index = Math.min(Math.max(Math.round(normalizedValue), 0), 255);\n\n    return colorMap[index];\n  });\n}\n\n/**\n * Converts a 4-byte Uint8Array to a Float32 value\n * @param bytes 4-byte Uint8Array\n * @returns Float32 value\n */\nfunction bytesToFloat32(bytes: Uint8Array): number {\n  const dataView = new DataView(bytes.buffer, bytes.byteOffset, 4);\n  return dataView.getFloat32(0, true); // true for little-endian\n}\n\n/**\n * Main script function to process point cloud data and color it based on SNR values\n * @param event Input event containing LiDAR point cloud data\n * @param globalVars Global variables for SNR bounds\n * @returns Modified point cloud with added color information\n */\nexport default function script(\n  event: Input<\"/point_cloud\">,\n  globalVars: GlobalVariables,\n): PointCloud {\n  // // Get the original point cloud data as a Uint8Array\n  const { data, point_stride: old_strid } = event.message;\n  const numPoints = Math.floor(data.length / old_strid);\n\n  // Calculate new stride\n  const new_strid = old_strid + 4 * 1; // 11 fields of 4 bytes each + 4 fields of 1 byte each (RGBA)\n\n  // Extract SNR values from all points\n  const snrValues = extractSnrValues(data, old_strid, numPoints);\n\n  // Create SNR color map and convert SNR values to RGB colors\n  const colorMap = createLinearColorMap(SNR_COLORS);\n  const rgbColors = mapSnrToRgb(\n    colorMap,\n    snrValues,\n    globalVars.min_snr_bound,\n    globalVars.max_snr_bound,\n  );\n\n  // Create the new point cloud data with added color information\n  const coloredPointCloud = createColorizedPointCloud(\n    data,\n    rgbColors,\n    old_strid,\n    new_strid,\n    numPoints,\n  );\n\n  // Return the modified point cloud message\n  return {\n    timestamp: {\n      sec: event.message.timestamp.sec,\n      nsec: event.message.timestamp.nsec,\n    },\n    frame_id: event.message.frame_id,\n    pose: {\n      position: {\n        x: 0,\n        y: 0,\n        z: 0,\n      },\n      orientation: {\n        x: 0,\n        y: 0,\n        z: 0,\n        w: 1,\n      },\n    },\n    point_stride: new_strid,\n    fields: event.message.fields.concat(\n      { name: \"red\", offset: 44, type: 1 },\n      { name: \"green\", offset: 45, type: 1 },\n      { name: \"blue\", offset: 46, type: 1 },\n      { name: \"alpha\", offset: 47, type: 1 },\n    ),\n    data: coloredPointCloud,\n  };\n}\n\n/**\n * Extracts SNR values from point cloud data\n * @param data Original point cloud data\n * @param stride Original point stride\n * @param numPoints Number of points\n * @returns Array of SNR values\n */\nfunction extractSnrValues(\n  data: Uint8Array,\n  stride: number,\n  numPoints: number,\n): number[] {\n  const snrValues: number[] = [];\n  const SNR_OFFSET = 24; // Offset to SNR value in each point\n\n  for (let i = 0; i < numPoints; i++) {\n    const pointOffset = i * stride;\n    const snrBytes = data.slice(\n      pointOffset + SNR_OFFSET,\n      pointOffset + SNR_OFFSET + 4,\n    );\n    const snrValue = bytesToFloat32(snrBytes);\n    snrValues.push(snrValue);\n  }\n\n  return snrValues;\n}\n\n/**\n * Creates a new point cloud with colorized points\n * @param sourceData Original point cloud data\n * @param colors RGB color values for each point\n * @param oldStride Original point stride in bytes\n * @param newStride New point stride in bytes\n * @param numPoints Number of points in the cloud\n * @returns New Uint8Array with original data plus colors\n */\nfunction createColorizedPointCloud(\n  sourceData: Uint8Array,\n  colors: number[][],\n  oldStride: number,\n  newStride: number,\n  numPoints: number,\n): Uint8Array {\n  const newSize = numPoints * newStride;\n  const newData = new Uint8Array(newSize);\n\n  for (let i = 0; i < numPoints; i++) {\n    const srcOffset = i * oldStride;\n    const dstOffset = i * newStride;\n\n    // Copy original point data\n    newData.set(\n      sourceData.subarray(srcOffset, srcOffset + oldStride),\n      dstOffset,\n    );\n\n    // Add color data\n    if (i < colors.length && colors[i]) {\n      const [r, g, b] = colors[i].map((v) =>\n        Math.round(Math.max(0, Math.min(255, v))),\n      );\n      newData.set([r, g, b, 255], dstOffset + oldStride);\n    } else {\n      // Fallback color if data is missing\n      newData.set([128, 128, 128, 255], dstOffset + oldStride);\n    }\n  }\n\n  return newData;\n}\n",
      "name": "snr_clr_add_fields.ts"
    },
    "87132b73-8226-4e15-9e26-b4dd44475001": {
      "sourceCode": "// Copyright (c) 2024-2025 Voyant Photonics, Inc.\n// All rights reserved.\n\nimport { Input } from \"./types\";\nimport { PointCloud } from \"@foxglove/schemas\";\n\n// The input and output topics for your script\nexport const inputs = [\"/point_cloud\"];\nexport const output = \"/dop_color_pointcloud\";\n\n//Type definitions\ntype GlobalVariables = {\n  min_dop_bound: number;\n  max_dop_bound: number;\n};\ntype RGBColor = [number, number, number];\n\n// Color constants\nconst DOPPLER_COLORS: RGBColor[] = [\n  [255.0, 0.0, 0.0], // Red for negative doppler (moving away)\n  [49.0, 49.0, 49.0], // Gray for zero doppler\n  [0.0, 100.0, 255.0], // Blue for positive doppler (moving toward)\n];\n\n// Pre-compute the color map\nconst dopColorMap = createLinearColorMap(DOPPLER_COLORS);\n\n/**\n * Creates a linear color gradient map between given color points\n * @param colors Array of RGB triplets defining the gradient points\n * @returns 2D array with 256 RGB color values\n */\nfunction createLinearColorMap(colors: RGBColor[]): number[][] {\n  // Extract colors from the input array\n  const [colorLow, colorMid, colorHigh] = colors;\n  const colorMap: number[][] = [];\n\n  // Create 256 interpolated colors\n  for (let i = 0; i < 256; i++) {\n    const normVal = i / 255.0;\n    let r, g, b;\n\n    if (normVal < 0.5) {\n      // Interpolate between low and mid\n      const factor = normVal * 2.0;\n      r = interpolate(colorLow[0], colorMid[0], factor);\n      g = interpolate(colorLow[1], colorMid[1], factor);\n      b = interpolate(colorLow[2], colorMid[2], factor);\n    } else {\n      // Interpolate between mid and high\n      const factor = (normVal - 0.5) * 2.0;\n      r = interpolate(colorMid[0], colorHigh[0], factor);\n      g = interpolate(colorMid[1], colorHigh[1], factor);\n      b = interpolate(colorMid[2], colorHigh[2], factor);\n    }\n\n    colorMap.push([r, g, b]);\n  }\n\n  return colorMap;\n}\n\n/**\n * Linear interpolation between two values\n * @param a Starting value\n * @param b Ending value\n * @param t Interpolation factor (0.0 to 1.0)\n * @returns Interpolated value\n */\nfunction interpolate(a: number, b: number, t: number): number {\n  return a + t * (b - a);\n}\n\n/**\n * Maps doppler velocity values to RGB colors using a predefined color map\n * @param colorMap The color mapping array (256 RGB values)\n * @param velocities Array of doppler velocity values\n * @param minDoppler Minimum doppler value for normalization\n * @param maxDoppler Maximum doppler value for normalization\n * @returns Array of RGB color values corresponding to input velocities\n */\nfunction mapDopplerToRGB(\n  colorMap: number[][],\n  velocities: number[],\n  minDoppler: number,\n  maxDoppler: number,\n): number[][] {\n  // Ensure min is negative (moving away) and max is positive (moving toward)\n  const minDop = -Math.abs(minDoppler);\n  const maxDop = Math.abs(maxDoppler);\n  const dopplerRange = maxDop - minDop;\n\n  return velocities.map((velocity) => {\n    // Normalize velocity to 0-255 range\n    const normalizedValue = Math.max(\n      0,\n      Math.min(255, Math.round(((velocity - minDop) / dopplerRange) * 255)),\n    );\n\n    // Return the corresponding color from the map with safe fallback\n    return colorMap[normalizedValue] || [0, 0, 0];\n  });\n}\n\n/**\n * Converts a 4-byte Uint8Array to a Float32 value\n * @param bytes 4-byte Uint8Array containing the float data\n * @returns Parsed float32 value\n */\nfunction uint8ArrayToFloat32(bytes: Uint8Array): number {\n  return new DataView(bytes.buffer).getFloat32(0, true); // true for little-endian\n}\n\n/**\n * Main script function to process point cloud data\n * @param event Input point cloud message\n * @param globalVars User-configurable parameters\n * @returns Processed point cloud with color data\n */\nexport default function script(\n  event: Input<\"/point_cloud\">,\n  globalVars: GlobalVariables,\n): PointCloud {\n  // Get the original point cloud data as a Uint8Array\n  const { data, point_stride: old_strid } = event.message;\n\n  // Calculate new stride\n  const new_strid = old_strid + 4 * 1; // 11 fields of 4 bytes each + 4 fields of 1 byte each (RGBA)\n  const numPoints = Math.floor(data.length / old_strid);\n\n  const dopplerValues = extractDopplerValues(data, old_strid, numPoints);\n\n  // Map the Doppler values to RGB colors\n  const dopplerColors = mapDopplerToRGB(\n    dopColorMap,\n    dopplerValues,\n    globalVars.min_dop_bound,\n    globalVars.max_dop_bound,\n  );\n\n  // Create a new point cloud with color data\n  // Create new point cloud with color data\n  const newPointCloud = createColorizedPointCloud(\n    data,\n    dopplerColors,\n    old_strid,\n    new_strid,\n    numPoints,\n  );\n\n  // Return the modified point cloud message\n  return {\n    timestamp: {\n      sec: event.message.timestamp.sec,\n      nsec: event.message.timestamp.nsec,\n    },\n    frame_id: event.message.frame_id,\n    pose: {\n      position: {\n        x: 0,\n        y: 0,\n        z: 0,\n      },\n      orientation: {\n        x: 0,\n        y: 0,\n        z: 0,\n        w: 1,\n      },\n    },\n    point_stride: new_strid,\n    fields: event.message.fields.concat(\n      { name: \"red\", offset: 44, type: 1 },\n      { name: \"green\", offset: 45, type: 1 },\n      { name: \"blue\", offset: 46, type: 1 },\n      { name: \"alpha\", offset: 47, type: 1 },\n    ),\n    data: newPointCloud,\n  };\n}\n\n/**\n * Extracts doppler velocity values from point cloud data\n * @param data Raw point cloud data\n * @param stride Point stride in bytes\n * @param numPoints Number of points in the cloud\n * @returns Array of doppler velocity values\n */\nfunction extractDopplerValues(\n  data: Uint8Array,\n  stride: number,\n  numPoints: number,\n): number[] {\n  const dopplerValues: number[] = [];\n  const DOPPLER_OFFSET = 20; // Doppler field offset in bytes\n\n  for (let i = 0; i < numPoints; i++) {\n    const pointOffset = i * stride;\n    const dopplerBytes = new Uint8Array(4);\n    dopplerBytes.set(\n      data.subarray(\n        pointOffset + DOPPLER_OFFSET,\n        pointOffset + DOPPLER_OFFSET + 4,\n      ),\n    );\n    dopplerValues.push(uint8ArrayToFloat32(dopplerBytes));\n  }\n\n  return dopplerValues;\n}\n\n/**\n * Creates a new point cloud with colorized points\n * @param sourceData Original point cloud data\n * @param colors RGB color values for each point\n * @param oldStride Original point stride in bytes\n * @param newStride New point stride in bytes\n * @param numPoints Number of points in the cloud\n * @returns New Uint8Array with original data plus colors\n */\nfunction createColorizedPointCloud(\n  sourceData: Uint8Array,\n  colors: number[][],\n  oldStride: number,\n  newStride: number,\n  numPoints: number,\n): Uint8Array {\n  const newSize = numPoints * newStride;\n  const newData = new Uint8Array(newSize);\n\n  for (let i = 0; i < numPoints; i++) {\n    const srcOffset = i * oldStride;\n    const dstOffset = i * newStride;\n\n    // Copy original point data\n    newData.set(\n      sourceData.subarray(srcOffset, srcOffset + oldStride),\n      dstOffset,\n    );\n\n    // Add color data\n    if (i < colors.length && colors[i]) {\n      const [r, g, b] = colors[i].map((v) =>\n        Math.round(Math.max(0, Math.min(255, v))),\n      );\n      newData.set([r, g, b, 255], dstOffset + oldStride);\n    } else {\n      // Fallback color if data is missing\n      newData.set([128, 128, 128, 255], dstOffset + oldStride);\n    }\n  }\n\n  return newData;\n}\n",
      "name": "dop_clr_add_fields.ts"
    },
    "0951bbfe-4683-437a-84e1-102e7f204624": {
      "sourceCode": "// Copyright (c) 2024-2025 Voyant Photonics, Inc.\n// All rights reserved.\n\nimport { Input } from \"./types\";\nimport { PointCloud } from \"@foxglove/schemas\";\n\n// Define constants\nconst BYTE_SIZE = {\n  FLOAT32: 4,\n  UINT8: 1,\n};\n\nconst COLOR_MAP_SIZE = 255;\nconst MAX_HUE = 360;\nconst MAX_SATURATION = 100;\nconst MAX_VALUE = 100;\nconst ALPHA_MAX = 255;\n\n// The input and output topics for your script\nexport const inputs = [\"/point_cloud\"];\nexport const output = \"/rng_color_pointcloud\";\n\ntype GlobalVariables = {\n  range_band: number;\n};\n\ninterface RGB {\n  r: number;\n  g: number;\n  b: number;\n}\n\n/**\n * Converts HSV color values to RGB\n * @param h - Hue (0-360)\n * @param s - Saturation (0-100)\n * @param v - Value (0-100)\n * @returns RGB color object with values 0-255\n */\nfunction hsvToRgb(h: number, s: number, v: number): RGB {\n  // Normalize values to [0,1] range\n  const hNorm = h / MAX_HUE;\n  const sNorm = s / MAX_SATURATION;\n  const vNorm = v / MAX_VALUE;\n\n  const i = Math.floor(hNorm * 6);\n  const f = hNorm * 6 - i;\n  const p = vNorm * (1 - sNorm);\n  const q = vNorm * (1 - f * sNorm);\n  const t = vNorm * (1 - (1 - f) * sNorm);\n\n  let r = 0,\n    g = 0,\n    b = 0;\n  switch (i % 6) {\n    case 0:\n      r = vNorm;\n      g = t;\n      b = p;\n      break;\n    case 1:\n      r = q;\n      g = vNorm;\n      b = p;\n      break;\n    case 2:\n      r = p;\n      g = vNorm;\n      b = t;\n      break;\n    case 3:\n      r = p;\n      g = q;\n      b = vNorm;\n      break;\n    case 4:\n      r = t;\n      g = p;\n      b = vNorm;\n      break;\n    case 5:\n      r = vNorm;\n      g = p;\n      b = q;\n      break;\n  }\n\n  return {\n    r: Math.round(r * 255),\n    g: Math.round(g * 255),\n    b: Math.round(b * 255),\n  };\n}\n\n/**\n * Converts a Uint8Array (4 bytes) to a Float32 value\n * @param bytes - Uint8Array containing 4 bytes\n * @returns Float32 value\n */\nfunction uint8ArrayToFloat32(bytes: Uint8Array): number {\n  const dataView = new DataView(bytes.buffer);\n  return dataView.getFloat32(0, true); // true for little-endian\n}\n\n/**\n * Creates a cyclic color map with evenly distributed hues\n * @param numColors - Number of colors in the map\n * @param saturation - Saturation value (0-100)\n * @param value - Brightness value (0-100)\n * @returns 2D array of RGB values [r,g,b]\n */\nfunction createCyclicColorMap(\n  numColors: number,\n  saturation: number,\n  value: number,\n): number[][] {\n  const colorMap: number[][] = [];\n\n  for (let i = 0; i < numColors; i++) {\n    const hue = (i / numColors) * MAX_HUE;\n    const { r, g, b } = hsvToRgb(hue, saturation, value);\n    colorMap.push([r, g, b]);\n  }\n\n  return colorMap;\n}\n\n/**\n * Maps range values to RGB colors using the provided color map\n * @param colorMap - 2D array of RGB values\n * @param rangeValues - Array of range values to map\n * @param bandSize - Size of each color band\n * @returns 2D array of RGB values for each input range value\n */\nfunction mapRangeToRgb(\n  colorMap: number[][],\n  rangeValues: number[],\n  bandSize: number,\n): number[][] {\n  // Normalize ranges into bands\n  const normalizedValues = rangeValues.map(\n    (val) => (val % bandSize) / bandSize,\n  );\n\n  // Map normalized values to color indices\n  const colorIndices = normalizedValues.map((val) =>\n    Math.floor(val * (COLOR_MAP_SIZE - 1)),\n  );\n\n  // Return RGB values from the color map\n  return colorIndices.map((index) => {\n    if (index >= 0 && index < colorMap.length) {\n      return colorMap[index];\n    }\n    return [0, 0, 0]; // Fallback for out-of-range indices\n  });\n}\n\n// Create a color map once for reuse\nconst rangeColorMap: number[][] = createCyclicColorMap(\n  COLOR_MAP_SIZE,\n  MAX_SATURATION,\n  MAX_VALUE,\n);\n\n/**\n * Main script function that processes the point cloud data\n * @param event - Input event containing the point cloud message\n * @param globalVars - Global variables including range_band\n * @returns Modified point cloud with color data\n */\nexport default function script(\n  event: Input<\"/point_cloud\">,\n  globalVars: GlobalVariables,\n): PointCloud {\n  // Get the original point cloud data as a Uint8Array\n  const { data, point_stride: old_strid } = event.message;\n  const new_strid = old_strid + 4 * BYTE_SIZE.UINT8; // 11 fields of 4 bytes each + 4 fields of 1 byte each (RGBA)\n  const numPoints = Math.floor(data.length / old_strid);\n  const new_size = numPoints * new_strid;\n  const new_point_cloud_data = new Uint8Array(new_size);\n\n  // Extract range values from the original point cloud\n  const rangeValues: number[] = [];\n  for (let i = 0; i < data.length; i += old_strid) {\n    if (i + 12 <= data.length) {\n      const rangeBytes = new Uint8Array(BYTE_SIZE.FLOAT32);\n      rangeBytes.set(data.subarray(i + 8, i + 12));\n      rangeValues.push(uint8ArrayToFloat32(rangeBytes));\n    }\n  }\n\n  // Map range values to colors\n  const colorValues = mapRangeToRgb(\n    rangeColorMap,\n    rangeValues,\n    globalVars.range_band,\n  );\n\n  // Copy original data and add color information\n  for (let i = 0; i < numPoints; i++) {\n    const originalOffset = i * old_strid;\n    const newOffset = i * new_strid;\n\n    // Copy original point data\n    new_point_cloud_data.set(\n      data.subarray(originalOffset, originalOffset + old_strid),\n      newOffset,\n    );\n\n    // Add color information\n    const color = i < colorValues.length ? colorValues[i] : [0, 0, 0];\n    new_point_cloud_data.set(\n      [\n        color[0] || 0, // Red\n        color[1] || 0, // Green\n        color[2] || 0, // Blue\n        ALPHA_MAX, // Alpha (fully opaque)\n      ],\n      newOffset + old_strid,\n    );\n  }\n\n  // Return the modified point cloud message\n  return {\n    timestamp: {\n      sec: event.message.timestamp.sec,\n      nsec: event.message.timestamp.nsec,\n    },\n    frame_id: event.message.frame_id,\n    pose: {\n      position: {\n        x: 0,\n        y: 0,\n        z: 0,\n      },\n      orientation: {\n        x: 0,\n        y: 0,\n        z: 0,\n        w: 1,\n      },\n    },\n    point_stride: new_strid,\n    fields: event.message.fields.concat(\n      { name: \"red\", offset: 44, type: 1 },\n      { name: \"green\", offset: 45, type: 1 },\n      { name: \"blue\", offset: 46, type: 1 },\n      { name: \"alpha\", offset: 47, type: 1 },\n    ),\n    data: new_point_cloud_data,\n  };\n}\n",
      "name": "rng_clr_band_add_fields.ts"
    }
  },
  "playbackConfig": {
    "speed": 1
  },
  "layout": {
    "first": {
      "first": {
        "first": "3D!e6sz0o",
        "second": "3D!1pnxa9v",
        "direction": "column"
      },
      "second": {
        "first": "3D!3dztaq2",
        "second": "3D!1sbddfc",
        "direction": "column",
        "splitPercentage": 50
      },
      "direction": "row",
      "splitPercentage": 50
    },
    "second": {
      "first": {
        "first": "GlobalVariableSliderPanel!2e7ijri",
        "second": {
          "first": {
            "first": "GlobalVariableSliderPanel!3qbvnjm",
            "second": "GlobalVariableSliderPanel!3q2vfoj",
            "direction": "column"
          },
          "second": "GlobalVariableSliderPanel!2gxsope",
          "direction": "column",
          "splitPercentage": 75
        },
        "direction": "column",
        "splitPercentage": 25
      },
      "second": "GlobalVariableSliderPanel!5wqrfj",
      "direction": "column",
      "splitPercentage": 77.13382507903056
    },
    "direction": "row",
    "splitPercentage": 87.79697624190065
  }
}